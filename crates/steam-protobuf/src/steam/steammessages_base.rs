// This file is generated by rust-protobuf 2.20.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]
#![allow(unused_attributes)]
#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `steammessages_base.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_20_0;

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgIPAddress {
    // message oneof groups
    pub ip: ::std::option::Option<CMsgIPAddress_oneof_ip>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgIPAddress {
    fn default() -> &'a CMsgIPAddress {
        <CMsgIPAddress as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum CMsgIPAddress_oneof_ip {
    v4(u32),
    v6(::std::vec::Vec<u8>),
}

impl CMsgIPAddress {
    pub fn new() -> CMsgIPAddress {
        ::std::default::Default::default()
    }

    // optional fixed32 v4 = 1;

    pub fn get_v4(&self) -> u32 {
        match self.ip {
            ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v4(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_v4(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_v4(&self) -> bool {
        match self.ip {
            ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v4(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v4(&mut self, v: u32) {
        self.ip = ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v4(v))
    }

    // optional bytes v6 = 2;

    pub fn get_v6(&self) -> &[u8] {
        match self.ip {
            ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v6(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_v6(&mut self) {
        self.ip = ::std::option::Option::None;
    }

    pub fn has_v6(&self) -> bool {
        match self.ip {
            ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_v6(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip = ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v6(v))
    }

    // Mutable pointer to the field.
    pub fn mut_v6(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v6(_)) = self.ip {
        } else {
            self.ip = ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v6(::std::vec::Vec::new()));
        }
        match self.ip {
            ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v6(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_v6(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_v6() {
            match self.ip.take() {
                ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v6(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for CMsgIPAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed32 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ip = ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v4(is.read_fixed32()?));
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ip = ::std::option::Option::Some(CMsgIPAddress_oneof_ip::v6(is.read_bytes()?));
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let ::std::option::Option::Some(ref v) = self.ip {
            match v {
                &CMsgIPAddress_oneof_ip::v4(v) => {
                    my_size += 5;
                }
                &CMsgIPAddress_oneof_ip::v6(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(2, &v);
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let ::std::option::Option::Some(ref v) = self.ip {
            match v {
                &CMsgIPAddress_oneof_ip::v4(v) => {
                    os.write_fixed32(1, v)?;
                }
                &CMsgIPAddress_oneof_ip::v6(ref v) => {
                    os.write_bytes(2, v)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgIPAddress {
        CMsgIPAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "v4",
                CMsgIPAddress::has_v4,
                CMsgIPAddress::get_v4,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "v6",
                CMsgIPAddress::has_v6,
                CMsgIPAddress::get_v6,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgIPAddress>(
                "CMsgIPAddress",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CMsgIPAddress {
        static instance: ::protobuf::rt::LazyV2<CMsgIPAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgIPAddress::new)
    }
}

impl ::protobuf::Clear for CMsgIPAddress {
    fn clear(&mut self) {
        self.ip = ::std::option::Option::None;
        self.ip = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgIPAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIPAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgIPAddressBucket {
    // message fields
    pub original_ip_address: ::protobuf::SingularPtrField<CMsgIPAddress>,
    bucket: ::std::option::Option<u64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgIPAddressBucket {
    fn default() -> &'a CMsgIPAddressBucket {
        <CMsgIPAddressBucket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgIPAddressBucket {
    pub fn new() -> CMsgIPAddressBucket {
        ::std::default::Default::default()
    }

    // optional .CMsgIPAddress original_ip_address = 1;

    pub fn get_original_ip_address(&self) -> &CMsgIPAddress {
        self.original_ip_address
            .as_ref()
            .unwrap_or_else(|| <CMsgIPAddress as ::protobuf::Message>::default_instance())
    }
    pub fn clear_original_ip_address(&mut self) {
        self.original_ip_address.clear();
    }

    pub fn has_original_ip_address(&self) -> bool {
        self.original_ip_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_original_ip_address(&mut self, v: CMsgIPAddress) {
        self.original_ip_address = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_ip_address(&mut self) -> &mut CMsgIPAddress {
        if self.original_ip_address.is_none() {
            self.original_ip_address.set_default();
        }
        self.original_ip_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_original_ip_address(&mut self) -> CMsgIPAddress {
        self.original_ip_address.take().unwrap_or_else(|| CMsgIPAddress::new())
    }

    // optional fixed64 bucket = 2;

    pub fn get_bucket(&self) -> u64 {
        self.bucket.unwrap_or(0)
    }
    pub fn clear_bucket(&mut self) {
        self.bucket = ::std::option::Option::None;
    }

    pub fn has_bucket(&self) -> bool {
        self.bucket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: u64) {
        self.bucket = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgIPAddressBucket {
    fn is_initialized(&self) -> bool {
        for v in &self.original_ip_address {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.original_ip_address)?;
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.bucket = ::std::option::Option::Some(tmp);
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.original_ip_address.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.bucket {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.original_ip_address.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.bucket {
            os.write_fixed64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgIPAddressBucket {
        CMsgIPAddressBucket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeMessage<CMsgIPAddress>,
            >(
                "original_ip_address",
                |m: &CMsgIPAddressBucket| &m.original_ip_address,
                |m: &mut CMsgIPAddressBucket| &mut m.original_ip_address,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "bucket",
                |m: &CMsgIPAddressBucket| &m.bucket,
                |m: &mut CMsgIPAddressBucket| &mut m.bucket,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgIPAddressBucket>(
                "CMsgIPAddressBucket",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CMsgIPAddressBucket {
        static instance: ::protobuf::rt::LazyV2<CMsgIPAddressBucket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgIPAddressBucket::new)
    }
}

impl ::protobuf::Clear for CMsgIPAddressBucket {
    fn clear(&mut self) {
        self.original_ip_address.clear();
        self.bucket = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgIPAddressBucket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgIPAddressBucket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgProtoBufHeader {
    // message fields
    steamid: ::std::option::Option<u64>,
    client_sessionid: ::std::option::Option<i32>,
    routing_appid: ::std::option::Option<u32>,
    jobid_source: ::std::option::Option<u64>,
    jobid_target: ::std::option::Option<u64>,
    target_job_name: ::protobuf::SingularField<::std::string::String>,
    seq_num: ::std::option::Option<i32>,
    eresult: ::std::option::Option<i32>,
    error_message: ::protobuf::SingularField<::std::string::String>,
    auth_account_flags: ::std::option::Option<u32>,
    token_source: ::std::option::Option<u32>,
    admin_spoofing_user: ::std::option::Option<bool>,
    transport_error: ::std::option::Option<i32>,
    messageid: ::std::option::Option<u64>,
    publisher_group_id: ::std::option::Option<u32>,
    sysid: ::std::option::Option<u32>,
    trace_tag: ::std::option::Option<u64>,
    webapi_key_id: ::std::option::Option<u32>,
    is_from_external_source: ::std::option::Option<bool>,
    pub forward_to_sysid: ::std::vec::Vec<u32>,
    cm_sysid: ::std::option::Option<u32>,
    wg_token: ::protobuf::SingularField<::std::string::String>,
    launcher_type: ::std::option::Option<u32>,
    realm: ::std::option::Option<u32>,
    // message oneof groups
    pub ip_addr: ::std::option::Option<CMsgProtoBufHeader_oneof_ip_addr>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgProtoBufHeader {
    fn default() -> &'a CMsgProtoBufHeader {
        <CMsgProtoBufHeader as ::protobuf::Message>::default_instance()
    }
}

#[derive(Clone, PartialEq, Debug)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum CMsgProtoBufHeader_oneof_ip_addr {
    ip(u32),
    ip_v6(::std::vec::Vec<u8>),
}

impl CMsgProtoBufHeader {
    pub fn new() -> CMsgProtoBufHeader {
        ::std::default::Default::default()
    }

    // optional fixed64 steamid = 1;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional int32 client_sessionid = 2;

    pub fn get_client_sessionid(&self) -> i32 {
        self.client_sessionid.unwrap_or(0)
    }
    pub fn clear_client_sessionid(&mut self) {
        self.client_sessionid = ::std::option::Option::None;
    }

    pub fn has_client_sessionid(&self) -> bool {
        self.client_sessionid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_client_sessionid(&mut self, v: i32) {
        self.client_sessionid = ::std::option::Option::Some(v);
    }

    // optional uint32 routing_appid = 3;

    pub fn get_routing_appid(&self) -> u32 {
        self.routing_appid.unwrap_or(0)
    }
    pub fn clear_routing_appid(&mut self) {
        self.routing_appid = ::std::option::Option::None;
    }

    pub fn has_routing_appid(&self) -> bool {
        self.routing_appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routing_appid(&mut self, v: u32) {
        self.routing_appid = ::std::option::Option::Some(v);
    }

    // optional fixed64 jobid_source = 10;

    pub fn get_jobid_source(&self) -> u64 {
        self.jobid_source.unwrap_or(18446744073709551615u64)
    }
    pub fn clear_jobid_source(&mut self) {
        self.jobid_source = ::std::option::Option::None;
    }

    pub fn has_jobid_source(&self) -> bool {
        self.jobid_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jobid_source(&mut self, v: u64) {
        self.jobid_source = ::std::option::Option::Some(v);
    }

    // optional fixed64 jobid_target = 11;

    pub fn get_jobid_target(&self) -> u64 {
        self.jobid_target.unwrap_or(18446744073709551615u64)
    }
    pub fn clear_jobid_target(&mut self) {
        self.jobid_target = ::std::option::Option::None;
    }

    pub fn has_jobid_target(&self) -> bool {
        self.jobid_target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jobid_target(&mut self, v: u64) {
        self.jobid_target = ::std::option::Option::Some(v);
    }

    // optional string target_job_name = 12;

    pub fn get_target_job_name(&self) -> &str {
        match self.target_job_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_target_job_name(&mut self) {
        self.target_job_name.clear();
    }

    pub fn has_target_job_name(&self) -> bool {
        self.target_job_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target_job_name(&mut self, v: ::std::string::String) {
        self.target_job_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target_job_name(&mut self) -> &mut ::std::string::String {
        if self.target_job_name.is_none() {
            self.target_job_name.set_default();
        }
        self.target_job_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_target_job_name(&mut self) -> ::std::string::String {
        self.target_job_name
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 seq_num = 24;

    pub fn get_seq_num(&self) -> i32 {
        self.seq_num.unwrap_or(0)
    }
    pub fn clear_seq_num(&mut self) {
        self.seq_num = ::std::option::Option::None;
    }

    pub fn has_seq_num(&self) -> bool {
        self.seq_num.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seq_num(&mut self, v: i32) {
        self.seq_num = ::std::option::Option::Some(v);
    }

    // optional int32 eresult = 13;

    pub fn get_eresult(&self) -> i32 {
        self.eresult.unwrap_or(2i32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: i32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional string error_message = 14;

    pub fn get_error_message(&self) -> &str {
        match self.error_message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error_message(&mut self) {
        self.error_message.clear();
    }

    pub fn has_error_message(&self) -> bool {
        self.error_message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error_message(&mut self, v: ::std::string::String) {
        self.error_message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error_message(&mut self) -> &mut ::std::string::String {
        if self.error_message.is_none() {
            self.error_message.set_default();
        }
        self.error_message.as_mut().unwrap()
    }

    // Take field
    pub fn take_error_message(&mut self) -> ::std::string::String {
        self.error_message
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 auth_account_flags = 16;

    pub fn get_auth_account_flags(&self) -> u32 {
        self.auth_account_flags.unwrap_or(0)
    }
    pub fn clear_auth_account_flags(&mut self) {
        self.auth_account_flags = ::std::option::Option::None;
    }

    pub fn has_auth_account_flags(&self) -> bool {
        self.auth_account_flags.is_some()
    }

    // Param is passed by value, moved
    pub fn set_auth_account_flags(&mut self, v: u32) {
        self.auth_account_flags = ::std::option::Option::Some(v);
    }

    // optional uint32 token_source = 22;

    pub fn get_token_source(&self) -> u32 {
        self.token_source.unwrap_or(0)
    }
    pub fn clear_token_source(&mut self) {
        self.token_source = ::std::option::Option::None;
    }

    pub fn has_token_source(&self) -> bool {
        self.token_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_token_source(&mut self, v: u32) {
        self.token_source = ::std::option::Option::Some(v);
    }

    // optional bool admin_spoofing_user = 23;

    pub fn get_admin_spoofing_user(&self) -> bool {
        self.admin_spoofing_user.unwrap_or(false)
    }
    pub fn clear_admin_spoofing_user(&mut self) {
        self.admin_spoofing_user = ::std::option::Option::None;
    }

    pub fn has_admin_spoofing_user(&self) -> bool {
        self.admin_spoofing_user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_admin_spoofing_user(&mut self, v: bool) {
        self.admin_spoofing_user = ::std::option::Option::Some(v);
    }

    // optional int32 transport_error = 17;

    pub fn get_transport_error(&self) -> i32 {
        self.transport_error.unwrap_or(1i32)
    }
    pub fn clear_transport_error(&mut self) {
        self.transport_error = ::std::option::Option::None;
    }

    pub fn has_transport_error(&self) -> bool {
        self.transport_error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_transport_error(&mut self, v: i32) {
        self.transport_error = ::std::option::Option::Some(v);
    }

    // optional uint64 messageid = 18;

    pub fn get_messageid(&self) -> u64 {
        self.messageid.unwrap_or(18446744073709551615u64)
    }
    pub fn clear_messageid(&mut self) {
        self.messageid = ::std::option::Option::None;
    }

    pub fn has_messageid(&self) -> bool {
        self.messageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_messageid(&mut self, v: u64) {
        self.messageid = ::std::option::Option::Some(v);
    }

    // optional uint32 publisher_group_id = 19;

    pub fn get_publisher_group_id(&self) -> u32 {
        self.publisher_group_id.unwrap_or(0)
    }
    pub fn clear_publisher_group_id(&mut self) {
        self.publisher_group_id = ::std::option::Option::None;
    }

    pub fn has_publisher_group_id(&self) -> bool {
        self.publisher_group_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publisher_group_id(&mut self, v: u32) {
        self.publisher_group_id = ::std::option::Option::Some(v);
    }

    // optional uint32 sysid = 20;

    pub fn get_sysid(&self) -> u32 {
        self.sysid.unwrap_or(0)
    }
    pub fn clear_sysid(&mut self) {
        self.sysid = ::std::option::Option::None;
    }

    pub fn has_sysid(&self) -> bool {
        self.sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sysid(&mut self, v: u32) {
        self.sysid = ::std::option::Option::Some(v);
    }

    // optional uint64 trace_tag = 21;

    pub fn get_trace_tag(&self) -> u64 {
        self.trace_tag.unwrap_or(0)
    }
    pub fn clear_trace_tag(&mut self) {
        self.trace_tag = ::std::option::Option::None;
    }

    pub fn has_trace_tag(&self) -> bool {
        self.trace_tag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_trace_tag(&mut self, v: u64) {
        self.trace_tag = ::std::option::Option::Some(v);
    }

    // optional uint32 webapi_key_id = 25;

    pub fn get_webapi_key_id(&self) -> u32 {
        self.webapi_key_id.unwrap_or(0)
    }
    pub fn clear_webapi_key_id(&mut self) {
        self.webapi_key_id = ::std::option::Option::None;
    }

    pub fn has_webapi_key_id(&self) -> bool {
        self.webapi_key_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_webapi_key_id(&mut self, v: u32) {
        self.webapi_key_id = ::std::option::Option::Some(v);
    }

    // optional bool is_from_external_source = 26;

    pub fn get_is_from_external_source(&self) -> bool {
        self.is_from_external_source.unwrap_or(false)
    }
    pub fn clear_is_from_external_source(&mut self) {
        self.is_from_external_source = ::std::option::Option::None;
    }

    pub fn has_is_from_external_source(&self) -> bool {
        self.is_from_external_source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_is_from_external_source(&mut self, v: bool) {
        self.is_from_external_source = ::std::option::Option::Some(v);
    }

    // repeated uint32 forward_to_sysid = 27;

    pub fn get_forward_to_sysid(&self) -> &[u32] {
        &self.forward_to_sysid
    }
    pub fn clear_forward_to_sysid(&mut self) {
        self.forward_to_sysid.clear();
    }

    // Param is passed by value, moved
    pub fn set_forward_to_sysid(&mut self, v: ::std::vec::Vec<u32>) {
        self.forward_to_sysid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_forward_to_sysid(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.forward_to_sysid
    }

    // Take field
    pub fn take_forward_to_sysid(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.forward_to_sysid, ::std::vec::Vec::new())
    }

    // optional uint32 cm_sysid = 28;

    pub fn get_cm_sysid(&self) -> u32 {
        self.cm_sysid.unwrap_or(0)
    }
    pub fn clear_cm_sysid(&mut self) {
        self.cm_sysid = ::std::option::Option::None;
    }

    pub fn has_cm_sysid(&self) -> bool {
        self.cm_sysid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cm_sysid(&mut self, v: u32) {
        self.cm_sysid = ::std::option::Option::Some(v);
    }

    // optional string wg_token = 30;

    pub fn get_wg_token(&self) -> &str {
        match self.wg_token.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_wg_token(&mut self) {
        self.wg_token.clear();
    }

    pub fn has_wg_token(&self) -> bool {
        self.wg_token.is_some()
    }

    // Param is passed by value, moved
    pub fn set_wg_token(&mut self, v: ::std::string::String) {
        self.wg_token = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_wg_token(&mut self) -> &mut ::std::string::String {
        if self.wg_token.is_none() {
            self.wg_token.set_default();
        }
        self.wg_token.as_mut().unwrap()
    }

    // Take field
    pub fn take_wg_token(&mut self) -> ::std::string::String {
        self.wg_token.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 launcher_type = 31;

    pub fn get_launcher_type(&self) -> u32 {
        self.launcher_type.unwrap_or(0u32)
    }
    pub fn clear_launcher_type(&mut self) {
        self.launcher_type = ::std::option::Option::None;
    }

    pub fn has_launcher_type(&self) -> bool {
        self.launcher_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_launcher_type(&mut self, v: u32) {
        self.launcher_type = ::std::option::Option::Some(v);
    }

    // optional uint32 realm = 32;

    pub fn get_realm(&self) -> u32 {
        self.realm.unwrap_or(0u32)
    }
    pub fn clear_realm(&mut self) {
        self.realm = ::std::option::Option::None;
    }

    pub fn has_realm(&self) -> bool {
        self.realm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_realm(&mut self, v: u32) {
        self.realm = ::std::option::Option::Some(v);
    }

    // optional uint32 ip = 15;

    pub fn get_ip(&self) -> u32 {
        match self.ip_addr {
            ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip(v)) => v,
            _ => 0,
        }
    }
    pub fn clear_ip(&mut self) {
        self.ip_addr = ::std::option::Option::None;
    }

    pub fn has_ip(&self) -> bool {
        match self.ip_addr {
            ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: u32) {
        self.ip_addr = ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip(v))
    }

    // optional bytes ip_v6 = 29;

    pub fn get_ip_v6(&self) -> &[u8] {
        match self.ip_addr {
            ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip_v6(ref v)) => v,
            _ => &[],
        }
    }
    pub fn clear_ip_v6(&mut self) {
        self.ip_addr = ::std::option::Option::None;
    }

    pub fn has_ip_v6(&self) -> bool {
        match self.ip_addr {
            ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip_v6(..)) => true,
            _ => false,
        }
    }

    // Param is passed by value, moved
    pub fn set_ip_v6(&mut self, v: ::std::vec::Vec<u8>) {
        self.ip_addr = ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip_v6(v))
    }

    // Mutable pointer to the field.
    pub fn mut_ip_v6(&mut self) -> &mut ::std::vec::Vec<u8> {
        if let ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip_v6(_)) = self.ip_addr {
        } else {
            self.ip_addr = ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip_v6(::std::vec::Vec::new()));
        }
        match self.ip_addr {
            ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip_v6(ref mut v)) => v,
            _ => panic!(),
        }
    }

    // Take field
    pub fn take_ip_v6(&mut self) -> ::std::vec::Vec<u8> {
        if self.has_ip_v6() {
            match self.ip_addr.take() {
                ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip_v6(v)) => v,
                _ => panic!(),
            }
        } else {
            ::std::vec::Vec::new()
        }
    }
}

impl ::protobuf::Message for CMsgProtoBufHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.client_sessionid = ::std::option::Option::Some(tmp);
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.routing_appid = ::std::option::Option::Some(tmp);
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.jobid_source = ::std::option::Option::Some(tmp);
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.jobid_target = ::std::option::Option::Some(tmp);
                }
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.target_job_name)?;
                }
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.seq_num = ::std::option::Option::Some(tmp);
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                }
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error_message)?;
                }
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.auth_account_flags = ::std::option::Option::Some(tmp);
                }
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.token_source = ::std::option::Option::Some(tmp);
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.admin_spoofing_user = ::std::option::Option::Some(tmp);
                }
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.transport_error = ::std::option::Option::Some(tmp);
                }
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.messageid = ::std::option::Option::Some(tmp);
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.publisher_group_id = ::std::option::Option::Some(tmp);
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.sysid = ::std::option::Option::Some(tmp);
                }
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.trace_tag = ::std::option::Option::Some(tmp);
                }
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.webapi_key_id = ::std::option::Option::Some(tmp);
                }
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_from_external_source = ::std::option::Option::Some(tmp);
                }
                27 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.forward_to_sysid)?;
                }
                28 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.cm_sysid = ::std::option::Option::Some(tmp);
                }
                30 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.wg_token)?;
                }
                31 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.launcher_type = ::std::option::Option::Some(tmp);
                }
                32 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.realm = ::std::option::Option::Some(tmp);
                }
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ip_addr = ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip(is.read_uint32()?));
                }
                29 => {
                    if wire_type != ::protobuf::wire_format::WireTypeLengthDelimited {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    self.ip_addr =
                        ::std::option::Option::Some(CMsgProtoBufHeader_oneof_ip_addr::ip_v6(is.read_bytes()?));
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.client_sessionid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.routing_appid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.jobid_source {
            my_size += 9;
        }
        if let Some(v) = self.jobid_target {
            my_size += 9;
        }
        if let Some(ref v) = self.target_job_name.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(v) = self.seq_num {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(13, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.error_message.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(v) = self.auth_account_flags {
            my_size += ::protobuf::rt::value_size(16, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.token_source {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.admin_spoofing_user {
            my_size += 3;
        }
        if let Some(v) = self.transport_error {
            my_size += ::protobuf::rt::value_size(17, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.messageid {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publisher_group_id {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sysid {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.trace_tag {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.webapi_key_id {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.is_from_external_source {
            my_size += 3;
        }
        for value in &self.forward_to_sysid {
            my_size += ::protobuf::rt::value_size(27, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.cm_sysid {
            my_size += ::protobuf::rt::value_size(28, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.wg_token.as_ref() {
            my_size += ::protobuf::rt::string_size(30, &v);
        }
        if let Some(v) = self.launcher_type {
            my_size += ::protobuf::rt::value_size(31, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.realm {
            my_size += ::protobuf::rt::value_size(32, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let ::std::option::Option::Some(ref v) = self.ip_addr {
            match v {
                &CMsgProtoBufHeader_oneof_ip_addr::ip(v) => {
                    my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
                }
                &CMsgProtoBufHeader_oneof_ip_addr::ip_v6(ref v) => {
                    my_size += ::protobuf::rt::bytes_size(29, &v);
                }
            };
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.steamid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.client_sessionid {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.routing_appid {
            os.write_uint32(3, v)?;
        }
        if let Some(v) = self.jobid_source {
            os.write_fixed64(10, v)?;
        }
        if let Some(v) = self.jobid_target {
            os.write_fixed64(11, v)?;
        }
        if let Some(ref v) = self.target_job_name.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(v) = self.seq_num {
            os.write_int32(24, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_int32(13, v)?;
        }
        if let Some(ref v) = self.error_message.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(v) = self.auth_account_flags {
            os.write_uint32(16, v)?;
        }
        if let Some(v) = self.token_source {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.admin_spoofing_user {
            os.write_bool(23, v)?;
        }
        if let Some(v) = self.transport_error {
            os.write_int32(17, v)?;
        }
        if let Some(v) = self.messageid {
            os.write_uint64(18, v)?;
        }
        if let Some(v) = self.publisher_group_id {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.sysid {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.trace_tag {
            os.write_uint64(21, v)?;
        }
        if let Some(v) = self.webapi_key_id {
            os.write_uint32(25, v)?;
        }
        if let Some(v) = self.is_from_external_source {
            os.write_bool(26, v)?;
        }
        for v in &self.forward_to_sysid {
            os.write_uint32(27, *v)?;
        }
        if let Some(v) = self.cm_sysid {
            os.write_uint32(28, v)?;
        }
        if let Some(ref v) = self.wg_token.as_ref() {
            os.write_string(30, &v)?;
        }
        if let Some(v) = self.launcher_type {
            os.write_uint32(31, v)?;
        }
        if let Some(v) = self.realm {
            os.write_uint32(32, v)?;
        }
        if let ::std::option::Option::Some(ref v) = self.ip_addr {
            match v {
                &CMsgProtoBufHeader_oneof_ip_addr::ip(v) => {
                    os.write_uint32(15, v)?;
                }
                &CMsgProtoBufHeader_oneof_ip_addr::ip_v6(ref v) => {
                    os.write_bytes(29, v)?;
                }
            };
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgProtoBufHeader {
        CMsgProtoBufHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "steamid",
                |m: &CMsgProtoBufHeader| &m.steamid,
                |m: &mut CMsgProtoBufHeader| &mut m.steamid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "client_sessionid",
                |m: &CMsgProtoBufHeader| &m.client_sessionid,
                |m: &mut CMsgProtoBufHeader| &mut m.client_sessionid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "routing_appid",
                |m: &CMsgProtoBufHeader| &m.routing_appid,
                |m: &mut CMsgProtoBufHeader| &mut m.routing_appid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "jobid_source",
                |m: &CMsgProtoBufHeader| &m.jobid_source,
                |m: &mut CMsgProtoBufHeader| &mut m.jobid_source,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "jobid_target",
                |m: &CMsgProtoBufHeader| &m.jobid_target,
                |m: &mut CMsgProtoBufHeader| &mut m.jobid_target,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "target_job_name",
                |m: &CMsgProtoBufHeader| &m.target_job_name,
                |m: &mut CMsgProtoBufHeader| &mut m.target_job_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "seq_num",
                |m: &CMsgProtoBufHeader| &m.seq_num,
                |m: &mut CMsgProtoBufHeader| &mut m.seq_num,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "eresult",
                |m: &CMsgProtoBufHeader| &m.eresult,
                |m: &mut CMsgProtoBufHeader| &mut m.eresult,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "error_message",
                |m: &CMsgProtoBufHeader| &m.error_message,
                |m: &mut CMsgProtoBufHeader| &mut m.error_message,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "auth_account_flags",
                |m: &CMsgProtoBufHeader| &m.auth_account_flags,
                |m: &mut CMsgProtoBufHeader| &mut m.auth_account_flags,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "token_source",
                |m: &CMsgProtoBufHeader| &m.token_source,
                |m: &mut CMsgProtoBufHeader| &mut m.token_source,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "admin_spoofing_user",
                |m: &CMsgProtoBufHeader| &m.admin_spoofing_user,
                |m: &mut CMsgProtoBufHeader| &mut m.admin_spoofing_user,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "transport_error",
                |m: &CMsgProtoBufHeader| &m.transport_error,
                |m: &mut CMsgProtoBufHeader| &mut m.transport_error,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "messageid",
                |m: &CMsgProtoBufHeader| &m.messageid,
                |m: &mut CMsgProtoBufHeader| &mut m.messageid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "publisher_group_id",
                |m: &CMsgProtoBufHeader| &m.publisher_group_id,
                |m: &mut CMsgProtoBufHeader| &mut m.publisher_group_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "sysid",
                |m: &CMsgProtoBufHeader| &m.sysid,
                |m: &mut CMsgProtoBufHeader| &mut m.sysid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "trace_tag",
                |m: &CMsgProtoBufHeader| &m.trace_tag,
                |m: &mut CMsgProtoBufHeader| &mut m.trace_tag,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "webapi_key_id",
                |m: &CMsgProtoBufHeader| &m.webapi_key_id,
                |m: &mut CMsgProtoBufHeader| &mut m.webapi_key_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "is_from_external_source",
                |m: &CMsgProtoBufHeader| &m.is_from_external_source,
                |m: &mut CMsgProtoBufHeader| &mut m.is_from_external_source,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "forward_to_sysid",
                |m: &CMsgProtoBufHeader| &m.forward_to_sysid,
                |m: &mut CMsgProtoBufHeader| &mut m.forward_to_sysid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "cm_sysid",
                |m: &CMsgProtoBufHeader| &m.cm_sysid,
                |m: &mut CMsgProtoBufHeader| &mut m.cm_sysid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "wg_token",
                |m: &CMsgProtoBufHeader| &m.wg_token,
                |m: &mut CMsgProtoBufHeader| &mut m.wg_token,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "launcher_type",
                |m: &CMsgProtoBufHeader| &m.launcher_type,
                |m: &mut CMsgProtoBufHeader| &mut m.launcher_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "realm",
                |m: &CMsgProtoBufHeader| &m.realm,
                |m: &mut CMsgProtoBufHeader| &mut m.realm,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_u32_accessor::<_>(
                "ip",
                CMsgProtoBufHeader::has_ip,
                CMsgProtoBufHeader::get_ip,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_bytes_accessor::<_>(
                "ip_v6",
                CMsgProtoBufHeader::has_ip_v6,
                CMsgProtoBufHeader::get_ip_v6,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgProtoBufHeader>(
                "CMsgProtoBufHeader",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CMsgProtoBufHeader {
        static instance: ::protobuf::rt::LazyV2<CMsgProtoBufHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgProtoBufHeader::new)
    }
}

impl ::protobuf::Clear for CMsgProtoBufHeader {
    fn clear(&mut self) {
        self.steamid = ::std::option::Option::None;
        self.client_sessionid = ::std::option::Option::None;
        self.routing_appid = ::std::option::Option::None;
        self.jobid_source = ::std::option::Option::None;
        self.jobid_target = ::std::option::Option::None;
        self.target_job_name.clear();
        self.seq_num = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.error_message.clear();
        self.auth_account_flags = ::std::option::Option::None;
        self.token_source = ::std::option::Option::None;
        self.admin_spoofing_user = ::std::option::Option::None;
        self.transport_error = ::std::option::Option::None;
        self.messageid = ::std::option::Option::None;
        self.publisher_group_id = ::std::option::Option::None;
        self.sysid = ::std::option::Option::None;
        self.trace_tag = ::std::option::Option::None;
        self.webapi_key_id = ::std::option::Option::None;
        self.is_from_external_source = ::std::option::Option::None;
        self.forward_to_sysid.clear();
        self.cm_sysid = ::std::option::Option::None;
        self.wg_token.clear();
        self.launcher_type = ::std::option::Option::None;
        self.realm = ::std::option::Option::None;
        self.ip_addr = ::std::option::Option::None;
        self.ip_addr = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProtoBufHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProtoBufHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgMulti {
    // message fields
    size_unzipped: ::std::option::Option<u32>,
    message_body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgMulti {
    fn default() -> &'a CMsgMulti {
        <CMsgMulti as ::protobuf::Message>::default_instance()
    }
}

impl CMsgMulti {
    pub fn new() -> CMsgMulti {
        ::std::default::Default::default()
    }

    // optional uint32 size_unzipped = 1;

    pub fn get_size_unzipped(&self) -> u32 {
        self.size_unzipped.unwrap_or(0)
    }
    pub fn clear_size_unzipped(&mut self) {
        self.size_unzipped = ::std::option::Option::None;
    }

    pub fn has_size_unzipped(&self) -> bool {
        self.size_unzipped.is_some()
    }

    // Param is passed by value, moved
    pub fn set_size_unzipped(&mut self, v: u32) {
        self.size_unzipped = ::std::option::Option::Some(v);
    }

    // optional bytes message_body = 2;

    pub fn get_message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_message_body(&mut self) {
        self.message_body.clear();
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body.set_default();
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgMulti {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.size_unzipped = ::std::option::Option::Some(tmp);
                }
                2 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message_body)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.size_unzipped {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.message_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.size_unzipped {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.message_body.as_ref() {
            os.write_bytes(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgMulti {
        CMsgMulti::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "size_unzipped",
                |m: &CMsgMulti| &m.size_unzipped,
                |m: &mut CMsgMulti| &mut m.size_unzipped,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBytes,
            >(
                "message_body",
                |m: &CMsgMulti| &m.message_body,
                |m: &mut CMsgMulti| &mut m.message_body,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgMulti>(
                "CMsgMulti",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CMsgMulti {
        static instance: ::protobuf::rt::LazyV2<CMsgMulti> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgMulti::new)
    }
}

impl ::protobuf::Clear for CMsgMulti {
    fn clear(&mut self) {
        self.size_unzipped = ::std::option::Option::None;
        self.message_body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgMulti {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgMulti {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgProtobufWrapped {
    // message fields
    message_body: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgProtobufWrapped {
    fn default() -> &'a CMsgProtobufWrapped {
        <CMsgProtobufWrapped as ::protobuf::Message>::default_instance()
    }
}

impl CMsgProtobufWrapped {
    pub fn new() -> CMsgProtobufWrapped {
        ::std::default::Default::default()
    }

    // optional bytes message_body = 1;

    pub fn get_message_body(&self) -> &[u8] {
        match self.message_body.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_message_body(&mut self) {
        self.message_body.clear();
    }

    pub fn has_message_body(&self) -> bool {
        self.message_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.message_body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.message_body.is_none() {
            self.message_body.set_default();
        }
        self.message_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_message_body(&mut self) -> ::std::vec::Vec<u8> {
        self.message_body.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgProtobufWrapped {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.message_body)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.message_body.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.message_body.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgProtobufWrapped {
        CMsgProtobufWrapped::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBytes,
            >(
                "message_body",
                |m: &CMsgProtobufWrapped| &m.message_body,
                |m: &mut CMsgProtobufWrapped| &mut m.message_body,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgProtobufWrapped>(
                "CMsgProtobufWrapped",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CMsgProtobufWrapped {
        static instance: ::protobuf::rt::LazyV2<CMsgProtobufWrapped> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgProtobufWrapped::new)
    }
}

impl ::protobuf::Clear for CMsgProtobufWrapped {
    fn clear(&mut self) {
        self.message_body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgProtobufWrapped {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgProtobufWrapped {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgAuthTicket {
    // message fields
    estate: ::std::option::Option<u32>,
    eresult: ::std::option::Option<u32>,
    steamid: ::std::option::Option<u64>,
    gameid: ::std::option::Option<u64>,
    h_steam_pipe: ::std::option::Option<u32>,
    ticket_crc: ::std::option::Option<u32>,
    ticket: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAuthTicket {
    fn default() -> &'a CMsgAuthTicket {
        <CMsgAuthTicket as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAuthTicket {
    pub fn new() -> CMsgAuthTicket {
        ::std::default::Default::default()
    }

    // optional uint32 estate = 1;

    pub fn get_estate(&self) -> u32 {
        self.estate.unwrap_or(0)
    }
    pub fn clear_estate(&mut self) {
        self.estate = ::std::option::Option::None;
    }

    pub fn has_estate(&self) -> bool {
        self.estate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_estate(&mut self, v: u32) {
        self.estate = ::std::option::Option::Some(v);
    }

    // optional uint32 eresult = 2;

    pub fn get_eresult(&self) -> u32 {
        self.eresult.unwrap_or(2u32)
    }
    pub fn clear_eresult(&mut self) {
        self.eresult = ::std::option::Option::None;
    }

    pub fn has_eresult(&self) -> bool {
        self.eresult.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eresult(&mut self, v: u32) {
        self.eresult = ::std::option::Option::Some(v);
    }

    // optional fixed64 steamid = 3;

    pub fn get_steamid(&self) -> u64 {
        self.steamid.unwrap_or(0)
    }
    pub fn clear_steamid(&mut self) {
        self.steamid = ::std::option::Option::None;
    }

    pub fn has_steamid(&self) -> bool {
        self.steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_steamid(&mut self, v: u64) {
        self.steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 gameid = 4;

    pub fn get_gameid(&self) -> u64 {
        self.gameid.unwrap_or(0)
    }
    pub fn clear_gameid(&mut self) {
        self.gameid = ::std::option::Option::None;
    }

    pub fn has_gameid(&self) -> bool {
        self.gameid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gameid(&mut self, v: u64) {
        self.gameid = ::std::option::Option::Some(v);
    }

    // optional uint32 h_steam_pipe = 5;

    pub fn get_h_steam_pipe(&self) -> u32 {
        self.h_steam_pipe.unwrap_or(0)
    }
    pub fn clear_h_steam_pipe(&mut self) {
        self.h_steam_pipe = ::std::option::Option::None;
    }

    pub fn has_h_steam_pipe(&self) -> bool {
        self.h_steam_pipe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_h_steam_pipe(&mut self, v: u32) {
        self.h_steam_pipe = ::std::option::Option::Some(v);
    }

    // optional uint32 ticket_crc = 6;

    pub fn get_ticket_crc(&self) -> u32 {
        self.ticket_crc.unwrap_or(0)
    }
    pub fn clear_ticket_crc(&mut self) {
        self.ticket_crc = ::std::option::Option::None;
    }

    pub fn has_ticket_crc(&self) -> bool {
        self.ticket_crc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket_crc(&mut self, v: u32) {
        self.ticket_crc = ::std::option::Option::Some(v);
    }

    // optional bytes ticket = 7;

    pub fn get_ticket(&self) -> &[u8] {
        match self.ticket.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_ticket(&mut self) {
        self.ticket.clear();
    }

    pub fn has_ticket(&self) -> bool {
        self.ticket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ticket(&mut self, v: ::std::vec::Vec<u8>) {
        self.ticket = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ticket(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.ticket.is_none() {
            self.ticket.set_default();
        }
        self.ticket.as_mut().unwrap()
    }

    // Take field
    pub fn take_ticket(&mut self) -> ::std::vec::Vec<u8> {
        self.ticket.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CMsgAuthTicket {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.estate = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.eresult = ::std::option::Option::Some(tmp);
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.steamid = ::std::option::Option::Some(tmp);
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gameid = ::std::option::Option::Some(tmp);
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.h_steam_pipe = ::std::option::Option::Some(tmp);
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ticket_crc = ::std::option::Option::Some(tmp);
                }
                7 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.ticket)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.estate {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.eresult {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.steamid {
            my_size += 9;
        }
        if let Some(v) = self.gameid {
            my_size += 9;
        }
        if let Some(v) = self.h_steam_pipe {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ticket_crc {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.ticket.as_ref() {
            my_size += ::protobuf::rt::bytes_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.estate {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.eresult {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.steamid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.gameid {
            os.write_fixed64(4, v)?;
        }
        if let Some(v) = self.h_steam_pipe {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.ticket_crc {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.ticket.as_ref() {
            os.write_bytes(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAuthTicket {
        CMsgAuthTicket::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "estate",
                |m: &CMsgAuthTicket| &m.estate,
                |m: &mut CMsgAuthTicket| &mut m.estate,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "eresult",
                |m: &CMsgAuthTicket| &m.eresult,
                |m: &mut CMsgAuthTicket| &mut m.eresult,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "steamid",
                |m: &CMsgAuthTicket| &m.steamid,
                |m: &mut CMsgAuthTicket| &mut m.steamid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "gameid",
                |m: &CMsgAuthTicket| &m.gameid,
                |m: &mut CMsgAuthTicket| &mut m.gameid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "h_steam_pipe",
                |m: &CMsgAuthTicket| &m.h_steam_pipe,
                |m: &mut CMsgAuthTicket| &mut m.h_steam_pipe,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "ticket_crc",
                |m: &CMsgAuthTicket| &m.ticket_crc,
                |m: &mut CMsgAuthTicket| &mut m.ticket_crc,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBytes,
            >(
                "ticket",
                |m: &CMsgAuthTicket| &m.ticket,
                |m: &mut CMsgAuthTicket| &mut m.ticket,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAuthTicket>(
                "CMsgAuthTicket",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CMsgAuthTicket {
        static instance: ::protobuf::rt::LazyV2<CMsgAuthTicket> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAuthTicket::new)
    }
}

impl ::protobuf::Clear for CMsgAuthTicket {
    fn clear(&mut self) {
        self.estate = ::std::option::Option::None;
        self.eresult = ::std::option::Option::None;
        self.steamid = ::std::option::Option::None;
        self.gameid = ::std::option::Option::None;
        self.h_steam_pipe = ::std::option::Option::None;
        self.ticket_crc = ::std::option::Option::None;
        self.ticket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAuthTicket {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAuthTicket {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CCDDBAppDetailCommon {
    // message fields
    appid: ::std::option::Option<u32>,
    name: ::protobuf::SingularField<::std::string::String>,
    icon: ::protobuf::SingularField<::std::string::String>,
    logo: ::protobuf::SingularField<::std::string::String>,
    logo_small: ::protobuf::SingularField<::std::string::String>,
    tool: ::std::option::Option<bool>,
    demo: ::std::option::Option<bool>,
    media: ::std::option::Option<bool>,
    community_visible_stats: ::std::option::Option<bool>,
    friendly_name: ::protobuf::SingularField<::std::string::String>,
    propagation: ::protobuf::SingularField<::std::string::String>,
    has_adult_content: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCDDBAppDetailCommon {
    fn default() -> &'a CCDDBAppDetailCommon {
        <CCDDBAppDetailCommon as ::protobuf::Message>::default_instance()
    }
}

impl CCDDBAppDetailCommon {
    pub fn new() -> CCDDBAppDetailCommon {
        ::std::default::Default::default()
    }

    // optional uint32 appid = 1;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string name = 2;

    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string icon = 3;

    pub fn get_icon(&self) -> &str {
        match self.icon.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_icon(&mut self) {
        self.icon.clear();
    }

    pub fn has_icon(&self) -> bool {
        self.icon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_icon(&mut self, v: ::std::string::String) {
        self.icon = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_icon(&mut self) -> &mut ::std::string::String {
        if self.icon.is_none() {
            self.icon.set_default();
        }
        self.icon.as_mut().unwrap()
    }

    // Take field
    pub fn take_icon(&mut self) -> ::std::string::String {
        self.icon.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string logo = 4;

    pub fn get_logo(&self) -> &str {
        match self.logo.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_logo(&mut self) {
        self.logo.clear();
    }

    pub fn has_logo(&self) -> bool {
        self.logo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logo(&mut self, v: ::std::string::String) {
        self.logo = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logo(&mut self) -> &mut ::std::string::String {
        if self.logo.is_none() {
            self.logo.set_default();
        }
        self.logo.as_mut().unwrap()
    }

    // Take field
    pub fn take_logo(&mut self) -> ::std::string::String {
        self.logo.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string logo_small = 5;

    pub fn get_logo_small(&self) -> &str {
        match self.logo_small.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_logo_small(&mut self) {
        self.logo_small.clear();
    }

    pub fn has_logo_small(&self) -> bool {
        self.logo_small.is_some()
    }

    // Param is passed by value, moved
    pub fn set_logo_small(&mut self, v: ::std::string::String) {
        self.logo_small = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logo_small(&mut self) -> &mut ::std::string::String {
        if self.logo_small.is_none() {
            self.logo_small.set_default();
        }
        self.logo_small.as_mut().unwrap()
    }

    // Take field
    pub fn take_logo_small(&mut self) -> ::std::string::String {
        self.logo_small.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool tool = 6;

    pub fn get_tool(&self) -> bool {
        self.tool.unwrap_or(false)
    }
    pub fn clear_tool(&mut self) {
        self.tool = ::std::option::Option::None;
    }

    pub fn has_tool(&self) -> bool {
        self.tool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tool(&mut self, v: bool) {
        self.tool = ::std::option::Option::Some(v);
    }

    // optional bool demo = 7;

    pub fn get_demo(&self) -> bool {
        self.demo.unwrap_or(false)
    }
    pub fn clear_demo(&mut self) {
        self.demo = ::std::option::Option::None;
    }

    pub fn has_demo(&self) -> bool {
        self.demo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_demo(&mut self, v: bool) {
        self.demo = ::std::option::Option::Some(v);
    }

    // optional bool media = 8;

    pub fn get_media(&self) -> bool {
        self.media.unwrap_or(false)
    }
    pub fn clear_media(&mut self) {
        self.media = ::std::option::Option::None;
    }

    pub fn has_media(&self) -> bool {
        self.media.is_some()
    }

    // Param is passed by value, moved
    pub fn set_media(&mut self, v: bool) {
        self.media = ::std::option::Option::Some(v);
    }

    // optional bool community_visible_stats = 9;

    pub fn get_community_visible_stats(&self) -> bool {
        self.community_visible_stats.unwrap_or(false)
    }
    pub fn clear_community_visible_stats(&mut self) {
        self.community_visible_stats = ::std::option::Option::None;
    }

    pub fn has_community_visible_stats(&self) -> bool {
        self.community_visible_stats.is_some()
    }

    // Param is passed by value, moved
    pub fn set_community_visible_stats(&mut self, v: bool) {
        self.community_visible_stats = ::std::option::Option::Some(v);
    }

    // optional string friendly_name = 10;

    pub fn get_friendly_name(&self) -> &str {
        match self.friendly_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_friendly_name(&mut self) {
        self.friendly_name.clear();
    }

    pub fn has_friendly_name(&self) -> bool {
        self.friendly_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_friendly_name(&mut self, v: ::std::string::String) {
        self.friendly_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_friendly_name(&mut self) -> &mut ::std::string::String {
        if self.friendly_name.is_none() {
            self.friendly_name.set_default();
        }
        self.friendly_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_friendly_name(&mut self) -> ::std::string::String {
        self.friendly_name
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string propagation = 11;

    pub fn get_propagation(&self) -> &str {
        match self.propagation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_propagation(&mut self) {
        self.propagation.clear();
    }

    pub fn has_propagation(&self) -> bool {
        self.propagation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagation(&mut self, v: ::std::string::String) {
        self.propagation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagation(&mut self) -> &mut ::std::string::String {
        if self.propagation.is_none() {
            self.propagation.set_default();
        }
        self.propagation.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagation(&mut self) -> ::std::string::String {
        self.propagation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool has_adult_content = 12;

    pub fn get_has_adult_content(&self) -> bool {
        self.has_adult_content.unwrap_or(false)
    }
    pub fn clear_has_adult_content(&mut self) {
        self.has_adult_content = ::std::option::Option::None;
    }

    pub fn has_has_adult_content(&self) -> bool {
        self.has_adult_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_has_adult_content(&mut self, v: bool) {
        self.has_adult_content = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCDDBAppDetailCommon {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                }
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                }
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.icon)?;
                }
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.logo)?;
                }
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.logo_small)?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tool = ::std::option::Option::Some(tmp);
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.demo = ::std::option::Option::Some(tmp);
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.media = ::std::option::Option::Some(tmp);
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.community_visible_stats = ::std::option::Option::Some(tmp);
                }
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.friendly_name)?;
                }
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.propagation)?;
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.has_adult_content = ::std::option::Option::Some(tmp);
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.icon.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.logo.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.logo_small.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.tool {
            my_size += 2;
        }
        if let Some(v) = self.demo {
            my_size += 2;
        }
        if let Some(v) = self.media {
            my_size += 2;
        }
        if let Some(v) = self.community_visible_stats {
            my_size += 2;
        }
        if let Some(ref v) = self.friendly_name.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.propagation.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.has_adult_content {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.appid {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.icon.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.logo.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.logo_small.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.tool {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.demo {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.media {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.community_visible_stats {
            os.write_bool(9, v)?;
        }
        if let Some(ref v) = self.friendly_name.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.propagation.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.has_adult_content {
            os.write_bool(12, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCDDBAppDetailCommon {
        CCDDBAppDetailCommon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "appid",
                |m: &CCDDBAppDetailCommon| &m.appid,
                |m: &mut CCDDBAppDetailCommon| &mut m.appid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "name",
                |m: &CCDDBAppDetailCommon| &m.name,
                |m: &mut CCDDBAppDetailCommon| &mut m.name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "icon",
                |m: &CCDDBAppDetailCommon| &m.icon,
                |m: &mut CCDDBAppDetailCommon| &mut m.icon,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "logo",
                |m: &CCDDBAppDetailCommon| &m.logo,
                |m: &mut CCDDBAppDetailCommon| &mut m.logo,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "logo_small",
                |m: &CCDDBAppDetailCommon| &m.logo_small,
                |m: &mut CCDDBAppDetailCommon| &mut m.logo_small,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "tool",
                |m: &CCDDBAppDetailCommon| &m.tool,
                |m: &mut CCDDBAppDetailCommon| &mut m.tool,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "demo",
                |m: &CCDDBAppDetailCommon| &m.demo,
                |m: &mut CCDDBAppDetailCommon| &mut m.demo,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "media",
                |m: &CCDDBAppDetailCommon| &m.media,
                |m: &mut CCDDBAppDetailCommon| &mut m.media,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "community_visible_stats",
                |m: &CCDDBAppDetailCommon| &m.community_visible_stats,
                |m: &mut CCDDBAppDetailCommon| &mut m.community_visible_stats,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "friendly_name",
                |m: &CCDDBAppDetailCommon| &m.friendly_name,
                |m: &mut CCDDBAppDetailCommon| &mut m.friendly_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "propagation",
                |m: &CCDDBAppDetailCommon| &m.propagation,
                |m: &mut CCDDBAppDetailCommon| &mut m.propagation,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "has_adult_content",
                |m: &CCDDBAppDetailCommon| &m.has_adult_content,
                |m: &mut CCDDBAppDetailCommon| &mut m.has_adult_content,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCDDBAppDetailCommon>(
                "CCDDBAppDetailCommon",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CCDDBAppDetailCommon {
        static instance: ::protobuf::rt::LazyV2<CCDDBAppDetailCommon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCDDBAppDetailCommon::new)
    }
}

impl ::protobuf::Clear for CCDDBAppDetailCommon {
    fn clear(&mut self) {
        self.appid = ::std::option::Option::None;
        self.name.clear();
        self.icon.clear();
        self.logo.clear();
        self.logo_small.clear();
        self.tool = ::std::option::Option::None;
        self.demo = ::std::option::Option::None;
        self.media = ::std::option::Option::None;
        self.community_visible_stats = ::std::option::Option::None;
        self.friendly_name.clear();
        self.propagation.clear();
        self.has_adult_content = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCDDBAppDetailCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCDDBAppDetailCommon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CMsgAppRights {
    // message fields
    edit_info: ::std::option::Option<bool>,
    publish: ::std::option::Option<bool>,
    view_error_data: ::std::option::Option<bool>,
    download: ::std::option::Option<bool>,
    upload_cdkeys: ::std::option::Option<bool>,
    generate_cdkeys: ::std::option::Option<bool>,
    view_financials: ::std::option::Option<bool>,
    manage_ceg: ::std::option::Option<bool>,
    manage_signing: ::std::option::Option<bool>,
    manage_cdkeys: ::std::option::Option<bool>,
    edit_marketing: ::std::option::Option<bool>,
    economy_support: ::std::option::Option<bool>,
    economy_support_supervisor: ::std::option::Option<bool>,
    manage_pricing: ::std::option::Option<bool>,
    broadcast_live: ::std::option::Option<bool>,
    view_marketing_traffic: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CMsgAppRights {
    fn default() -> &'a CMsgAppRights {
        <CMsgAppRights as ::protobuf::Message>::default_instance()
    }
}

impl CMsgAppRights {
    pub fn new() -> CMsgAppRights {
        ::std::default::Default::default()
    }

    // optional bool edit_info = 1;

    pub fn get_edit_info(&self) -> bool {
        self.edit_info.unwrap_or(false)
    }
    pub fn clear_edit_info(&mut self) {
        self.edit_info = ::std::option::Option::None;
    }

    pub fn has_edit_info(&self) -> bool {
        self.edit_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_info(&mut self, v: bool) {
        self.edit_info = ::std::option::Option::Some(v);
    }

    // optional bool publish = 2;

    pub fn get_publish(&self) -> bool {
        self.publish.unwrap_or(false)
    }
    pub fn clear_publish(&mut self) {
        self.publish = ::std::option::Option::None;
    }

    pub fn has_publish(&self) -> bool {
        self.publish.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publish(&mut self, v: bool) {
        self.publish = ::std::option::Option::Some(v);
    }

    // optional bool view_error_data = 3;

    pub fn get_view_error_data(&self) -> bool {
        self.view_error_data.unwrap_or(false)
    }
    pub fn clear_view_error_data(&mut self) {
        self.view_error_data = ::std::option::Option::None;
    }

    pub fn has_view_error_data(&self) -> bool {
        self.view_error_data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_error_data(&mut self, v: bool) {
        self.view_error_data = ::std::option::Option::Some(v);
    }

    // optional bool download = 4;

    pub fn get_download(&self) -> bool {
        self.download.unwrap_or(false)
    }
    pub fn clear_download(&mut self) {
        self.download = ::std::option::Option::None;
    }

    pub fn has_download(&self) -> bool {
        self.download.is_some()
    }

    // Param is passed by value, moved
    pub fn set_download(&mut self, v: bool) {
        self.download = ::std::option::Option::Some(v);
    }

    // optional bool upload_cdkeys = 5;

    pub fn get_upload_cdkeys(&self) -> bool {
        self.upload_cdkeys.unwrap_or(false)
    }
    pub fn clear_upload_cdkeys(&mut self) {
        self.upload_cdkeys = ::std::option::Option::None;
    }

    pub fn has_upload_cdkeys(&self) -> bool {
        self.upload_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_upload_cdkeys(&mut self, v: bool) {
        self.upload_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool generate_cdkeys = 6;

    pub fn get_generate_cdkeys(&self) -> bool {
        self.generate_cdkeys.unwrap_or(false)
    }
    pub fn clear_generate_cdkeys(&mut self) {
        self.generate_cdkeys = ::std::option::Option::None;
    }

    pub fn has_generate_cdkeys(&self) -> bool {
        self.generate_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generate_cdkeys(&mut self, v: bool) {
        self.generate_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool view_financials = 7;

    pub fn get_view_financials(&self) -> bool {
        self.view_financials.unwrap_or(false)
    }
    pub fn clear_view_financials(&mut self) {
        self.view_financials = ::std::option::Option::None;
    }

    pub fn has_view_financials(&self) -> bool {
        self.view_financials.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_financials(&mut self, v: bool) {
        self.view_financials = ::std::option::Option::Some(v);
    }

    // optional bool manage_ceg = 8;

    pub fn get_manage_ceg(&self) -> bool {
        self.manage_ceg.unwrap_or(false)
    }
    pub fn clear_manage_ceg(&mut self) {
        self.manage_ceg = ::std::option::Option::None;
    }

    pub fn has_manage_ceg(&self) -> bool {
        self.manage_ceg.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_ceg(&mut self, v: bool) {
        self.manage_ceg = ::std::option::Option::Some(v);
    }

    // optional bool manage_signing = 9;

    pub fn get_manage_signing(&self) -> bool {
        self.manage_signing.unwrap_or(false)
    }
    pub fn clear_manage_signing(&mut self) {
        self.manage_signing = ::std::option::Option::None;
    }

    pub fn has_manage_signing(&self) -> bool {
        self.manage_signing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_signing(&mut self, v: bool) {
        self.manage_signing = ::std::option::Option::Some(v);
    }

    // optional bool manage_cdkeys = 10;

    pub fn get_manage_cdkeys(&self) -> bool {
        self.manage_cdkeys.unwrap_or(false)
    }
    pub fn clear_manage_cdkeys(&mut self) {
        self.manage_cdkeys = ::std::option::Option::None;
    }

    pub fn has_manage_cdkeys(&self) -> bool {
        self.manage_cdkeys.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_cdkeys(&mut self, v: bool) {
        self.manage_cdkeys = ::std::option::Option::Some(v);
    }

    // optional bool edit_marketing = 11;

    pub fn get_edit_marketing(&self) -> bool {
        self.edit_marketing.unwrap_or(false)
    }
    pub fn clear_edit_marketing(&mut self) {
        self.edit_marketing = ::std::option::Option::None;
    }

    pub fn has_edit_marketing(&self) -> bool {
        self.edit_marketing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_edit_marketing(&mut self, v: bool) {
        self.edit_marketing = ::std::option::Option::Some(v);
    }

    // optional bool economy_support = 12;

    pub fn get_economy_support(&self) -> bool {
        self.economy_support.unwrap_or(false)
    }
    pub fn clear_economy_support(&mut self) {
        self.economy_support = ::std::option::Option::None;
    }

    pub fn has_economy_support(&self) -> bool {
        self.economy_support.is_some()
    }

    // Param is passed by value, moved
    pub fn set_economy_support(&mut self, v: bool) {
        self.economy_support = ::std::option::Option::Some(v);
    }

    // optional bool economy_support_supervisor = 13;

    pub fn get_economy_support_supervisor(&self) -> bool {
        self.economy_support_supervisor.unwrap_or(false)
    }
    pub fn clear_economy_support_supervisor(&mut self) {
        self.economy_support_supervisor = ::std::option::Option::None;
    }

    pub fn has_economy_support_supervisor(&self) -> bool {
        self.economy_support_supervisor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_economy_support_supervisor(&mut self, v: bool) {
        self.economy_support_supervisor = ::std::option::Option::Some(v);
    }

    // optional bool manage_pricing = 14;

    pub fn get_manage_pricing(&self) -> bool {
        self.manage_pricing.unwrap_or(false)
    }
    pub fn clear_manage_pricing(&mut self) {
        self.manage_pricing = ::std::option::Option::None;
    }

    pub fn has_manage_pricing(&self) -> bool {
        self.manage_pricing.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manage_pricing(&mut self, v: bool) {
        self.manage_pricing = ::std::option::Option::Some(v);
    }

    // optional bool broadcast_live = 15;

    pub fn get_broadcast_live(&self) -> bool {
        self.broadcast_live.unwrap_or(false)
    }
    pub fn clear_broadcast_live(&mut self) {
        self.broadcast_live = ::std::option::Option::None;
    }

    pub fn has_broadcast_live(&self) -> bool {
        self.broadcast_live.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcast_live(&mut self, v: bool) {
        self.broadcast_live = ::std::option::Option::Some(v);
    }

    // optional bool view_marketing_traffic = 16;

    pub fn get_view_marketing_traffic(&self) -> bool {
        self.view_marketing_traffic.unwrap_or(false)
    }
    pub fn clear_view_marketing_traffic(&mut self) {
        self.view_marketing_traffic = ::std::option::Option::None;
    }

    pub fn has_view_marketing_traffic(&self) -> bool {
        self.view_marketing_traffic.is_some()
    }

    // Param is passed by value, moved
    pub fn set_view_marketing_traffic(&mut self, v: bool) {
        self.view_marketing_traffic = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CMsgAppRights {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.edit_info = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.publish = ::std::option::Option::Some(tmp);
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.view_error_data = ::std::option::Option::Some(tmp);
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.download = ::std::option::Option::Some(tmp);
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.upload_cdkeys = ::std::option::Option::Some(tmp);
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.generate_cdkeys = ::std::option::Option::Some(tmp);
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.view_financials = ::std::option::Option::Some(tmp);
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.manage_ceg = ::std::option::Option::Some(tmp);
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.manage_signing = ::std::option::Option::Some(tmp);
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.manage_cdkeys = ::std::option::Option::Some(tmp);
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.edit_marketing = ::std::option::Option::Some(tmp);
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.economy_support = ::std::option::Option::Some(tmp);
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.economy_support_supervisor = ::std::option::Option::Some(tmp);
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.manage_pricing = ::std::option::Option::Some(tmp);
                }
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.broadcast_live = ::std::option::Option::Some(tmp);
                }
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.view_marketing_traffic = ::std::option::Option::Some(tmp);
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.edit_info {
            my_size += 2;
        }
        if let Some(v) = self.publish {
            my_size += 2;
        }
        if let Some(v) = self.view_error_data {
            my_size += 2;
        }
        if let Some(v) = self.download {
            my_size += 2;
        }
        if let Some(v) = self.upload_cdkeys {
            my_size += 2;
        }
        if let Some(v) = self.generate_cdkeys {
            my_size += 2;
        }
        if let Some(v) = self.view_financials {
            my_size += 2;
        }
        if let Some(v) = self.manage_ceg {
            my_size += 2;
        }
        if let Some(v) = self.manage_signing {
            my_size += 2;
        }
        if let Some(v) = self.manage_cdkeys {
            my_size += 2;
        }
        if let Some(v) = self.edit_marketing {
            my_size += 2;
        }
        if let Some(v) = self.economy_support {
            my_size += 2;
        }
        if let Some(v) = self.economy_support_supervisor {
            my_size += 2;
        }
        if let Some(v) = self.manage_pricing {
            my_size += 2;
        }
        if let Some(v) = self.broadcast_live {
            my_size += 2;
        }
        if let Some(v) = self.view_marketing_traffic {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.edit_info {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.publish {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.view_error_data {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.download {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.upload_cdkeys {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.generate_cdkeys {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.view_financials {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.manage_ceg {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.manage_signing {
            os.write_bool(9, v)?;
        }
        if let Some(v) = self.manage_cdkeys {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.edit_marketing {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.economy_support {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.economy_support_supervisor {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.manage_pricing {
            os.write_bool(14, v)?;
        }
        if let Some(v) = self.broadcast_live {
            os.write_bool(15, v)?;
        }
        if let Some(v) = self.view_marketing_traffic {
            os.write_bool(16, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CMsgAppRights {
        CMsgAppRights::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "edit_info",
                |m: &CMsgAppRights| &m.edit_info,
                |m: &mut CMsgAppRights| &mut m.edit_info,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "publish",
                |m: &CMsgAppRights| &m.publish,
                |m: &mut CMsgAppRights| &mut m.publish,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "view_error_data",
                |m: &CMsgAppRights| &m.view_error_data,
                |m: &mut CMsgAppRights| &mut m.view_error_data,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "download",
                |m: &CMsgAppRights| &m.download,
                |m: &mut CMsgAppRights| &mut m.download,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "upload_cdkeys",
                |m: &CMsgAppRights| &m.upload_cdkeys,
                |m: &mut CMsgAppRights| &mut m.upload_cdkeys,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "generate_cdkeys",
                |m: &CMsgAppRights| &m.generate_cdkeys,
                |m: &mut CMsgAppRights| &mut m.generate_cdkeys,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "view_financials",
                |m: &CMsgAppRights| &m.view_financials,
                |m: &mut CMsgAppRights| &mut m.view_financials,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "manage_ceg",
                |m: &CMsgAppRights| &m.manage_ceg,
                |m: &mut CMsgAppRights| &mut m.manage_ceg,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "manage_signing",
                |m: &CMsgAppRights| &m.manage_signing,
                |m: &mut CMsgAppRights| &mut m.manage_signing,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "manage_cdkeys",
                |m: &CMsgAppRights| &m.manage_cdkeys,
                |m: &mut CMsgAppRights| &mut m.manage_cdkeys,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "edit_marketing",
                |m: &CMsgAppRights| &m.edit_marketing,
                |m: &mut CMsgAppRights| &mut m.edit_marketing,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "economy_support",
                |m: &CMsgAppRights| &m.economy_support,
                |m: &mut CMsgAppRights| &mut m.economy_support,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "economy_support_supervisor",
                |m: &CMsgAppRights| &m.economy_support_supervisor,
                |m: &mut CMsgAppRights| &mut m.economy_support_supervisor,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "manage_pricing",
                |m: &CMsgAppRights| &m.manage_pricing,
                |m: &mut CMsgAppRights| &mut m.manage_pricing,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "broadcast_live",
                |m: &CMsgAppRights| &m.broadcast_live,
                |m: &mut CMsgAppRights| &mut m.broadcast_live,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "view_marketing_traffic",
                |m: &CMsgAppRights| &m.view_marketing_traffic,
                |m: &mut CMsgAppRights| &mut m.view_marketing_traffic,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CMsgAppRights>(
                "CMsgAppRights",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CMsgAppRights {
        static instance: ::protobuf::rt::LazyV2<CMsgAppRights> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CMsgAppRights::new)
    }
}

impl ::protobuf::Clear for CMsgAppRights {
    fn clear(&mut self) {
        self.edit_info = ::std::option::Option::None;
        self.publish = ::std::option::Option::None;
        self.view_error_data = ::std::option::Option::None;
        self.download = ::std::option::Option::None;
        self.upload_cdkeys = ::std::option::Option::None;
        self.generate_cdkeys = ::std::option::Option::None;
        self.view_financials = ::std::option::Option::None;
        self.manage_ceg = ::std::option::Option::None;
        self.manage_signing = ::std::option::Option::None;
        self.manage_cdkeys = ::std::option::Option::None;
        self.edit_marketing = ::std::option::Option::None;
        self.economy_support = ::std::option::Option::None;
        self.economy_support_supervisor = ::std::option::Option::None;
        self.manage_pricing = ::std::option::Option::None;
        self.broadcast_live = ::std::option::Option::None;
        self.view_marketing_traffic = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CMsgAppRights {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CMsgAppRights {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CCuratorPreferences {
    // message fields
    supported_languages: ::std::option::Option<u32>,
    platform_windows: ::std::option::Option<bool>,
    platform_mac: ::std::option::Option<bool>,
    platform_linux: ::std::option::Option<bool>,
    vr_content: ::std::option::Option<bool>,
    adult_content_violence: ::std::option::Option<bool>,
    adult_content_sex: ::std::option::Option<bool>,
    timestamp_updated: ::std::option::Option<u32>,
    pub tagids_curated: ::std::vec::Vec<u32>,
    pub tagids_filtered: ::std::vec::Vec<u32>,
    website_title: ::protobuf::SingularField<::std::string::String>,
    website_url: ::protobuf::SingularField<::std::string::String>,
    discussion_url: ::protobuf::SingularField<::std::string::String>,
    show_broadcast: ::std::option::Option<bool>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCuratorPreferences {
    fn default() -> &'a CCuratorPreferences {
        <CCuratorPreferences as ::protobuf::Message>::default_instance()
    }
}

impl CCuratorPreferences {
    pub fn new() -> CCuratorPreferences {
        ::std::default::Default::default()
    }

    // optional uint32 supported_languages = 1;

    pub fn get_supported_languages(&self) -> u32 {
        self.supported_languages.unwrap_or(0)
    }
    pub fn clear_supported_languages(&mut self) {
        self.supported_languages = ::std::option::Option::None;
    }

    pub fn has_supported_languages(&self) -> bool {
        self.supported_languages.is_some()
    }

    // Param is passed by value, moved
    pub fn set_supported_languages(&mut self, v: u32) {
        self.supported_languages = ::std::option::Option::Some(v);
    }

    // optional bool platform_windows = 2;

    pub fn get_platform_windows(&self) -> bool {
        self.platform_windows.unwrap_or(false)
    }
    pub fn clear_platform_windows(&mut self) {
        self.platform_windows = ::std::option::Option::None;
    }

    pub fn has_platform_windows(&self) -> bool {
        self.platform_windows.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_windows(&mut self, v: bool) {
        self.platform_windows = ::std::option::Option::Some(v);
    }

    // optional bool platform_mac = 3;

    pub fn get_platform_mac(&self) -> bool {
        self.platform_mac.unwrap_or(false)
    }
    pub fn clear_platform_mac(&mut self) {
        self.platform_mac = ::std::option::Option::None;
    }

    pub fn has_platform_mac(&self) -> bool {
        self.platform_mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_mac(&mut self, v: bool) {
        self.platform_mac = ::std::option::Option::Some(v);
    }

    // optional bool platform_linux = 4;

    pub fn get_platform_linux(&self) -> bool {
        self.platform_linux.unwrap_or(false)
    }
    pub fn clear_platform_linux(&mut self) {
        self.platform_linux = ::std::option::Option::None;
    }

    pub fn has_platform_linux(&self) -> bool {
        self.platform_linux.is_some()
    }

    // Param is passed by value, moved
    pub fn set_platform_linux(&mut self, v: bool) {
        self.platform_linux = ::std::option::Option::Some(v);
    }

    // optional bool vr_content = 5;

    pub fn get_vr_content(&self) -> bool {
        self.vr_content.unwrap_or(false)
    }
    pub fn clear_vr_content(&mut self) {
        self.vr_content = ::std::option::Option::None;
    }

    pub fn has_vr_content(&self) -> bool {
        self.vr_content.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vr_content(&mut self, v: bool) {
        self.vr_content = ::std::option::Option::Some(v);
    }

    // optional bool adult_content_violence = 6;

    pub fn get_adult_content_violence(&self) -> bool {
        self.adult_content_violence.unwrap_or(false)
    }
    pub fn clear_adult_content_violence(&mut self) {
        self.adult_content_violence = ::std::option::Option::None;
    }

    pub fn has_adult_content_violence(&self) -> bool {
        self.adult_content_violence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_content_violence(&mut self, v: bool) {
        self.adult_content_violence = ::std::option::Option::Some(v);
    }

    // optional bool adult_content_sex = 7;

    pub fn get_adult_content_sex(&self) -> bool {
        self.adult_content_sex.unwrap_or(false)
    }
    pub fn clear_adult_content_sex(&mut self) {
        self.adult_content_sex = ::std::option::Option::None;
    }

    pub fn has_adult_content_sex(&self) -> bool {
        self.adult_content_sex.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adult_content_sex(&mut self, v: bool) {
        self.adult_content_sex = ::std::option::Option::Some(v);
    }

    // optional uint32 timestamp_updated = 8;

    pub fn get_timestamp_updated(&self) -> u32 {
        self.timestamp_updated.unwrap_or(0)
    }
    pub fn clear_timestamp_updated(&mut self) {
        self.timestamp_updated = ::std::option::Option::None;
    }

    pub fn has_timestamp_updated(&self) -> bool {
        self.timestamp_updated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamp_updated(&mut self, v: u32) {
        self.timestamp_updated = ::std::option::Option::Some(v);
    }

    // repeated uint32 tagids_curated = 9;

    pub fn get_tagids_curated(&self) -> &[u32] {
        &self.tagids_curated
    }
    pub fn clear_tagids_curated(&mut self) {
        self.tagids_curated.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagids_curated(&mut self, v: ::std::vec::Vec<u32>) {
        self.tagids_curated = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagids_curated(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tagids_curated
    }

    // Take field
    pub fn take_tagids_curated(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tagids_curated, ::std::vec::Vec::new())
    }

    // repeated uint32 tagids_filtered = 10;

    pub fn get_tagids_filtered(&self) -> &[u32] {
        &self.tagids_filtered
    }
    pub fn clear_tagids_filtered(&mut self) {
        self.tagids_filtered.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagids_filtered(&mut self, v: ::std::vec::Vec<u32>) {
        self.tagids_filtered = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagids_filtered(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.tagids_filtered
    }

    // Take field
    pub fn take_tagids_filtered(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.tagids_filtered, ::std::vec::Vec::new())
    }

    // optional string website_title = 11;

    pub fn get_website_title(&self) -> &str {
        match self.website_title.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_website_title(&mut self) {
        self.website_title.clear();
    }

    pub fn has_website_title(&self) -> bool {
        self.website_title.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website_title(&mut self, v: ::std::string::String) {
        self.website_title = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website_title(&mut self) -> &mut ::std::string::String {
        if self.website_title.is_none() {
            self.website_title.set_default();
        }
        self.website_title.as_mut().unwrap()
    }

    // Take field
    pub fn take_website_title(&mut self) -> ::std::string::String {
        self.website_title
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string website_url = 12;

    pub fn get_website_url(&self) -> &str {
        match self.website_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_website_url(&mut self) {
        self.website_url.clear();
    }

    pub fn has_website_url(&self) -> bool {
        self.website_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_website_url(&mut self, v: ::std::string::String) {
        self.website_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_website_url(&mut self) -> &mut ::std::string::String {
        if self.website_url.is_none() {
            self.website_url.set_default();
        }
        self.website_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_website_url(&mut self) -> ::std::string::String {
        self.website_url.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string discussion_url = 13;

    pub fn get_discussion_url(&self) -> &str {
        match self.discussion_url.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_discussion_url(&mut self) {
        self.discussion_url.clear();
    }

    pub fn has_discussion_url(&self) -> bool {
        self.discussion_url.is_some()
    }

    // Param is passed by value, moved
    pub fn set_discussion_url(&mut self, v: ::std::string::String) {
        self.discussion_url = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_discussion_url(&mut self) -> &mut ::std::string::String {
        if self.discussion_url.is_none() {
            self.discussion_url.set_default();
        }
        self.discussion_url.as_mut().unwrap()
    }

    // Take field
    pub fn take_discussion_url(&mut self) -> ::std::string::String {
        self.discussion_url
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool show_broadcast = 14;

    pub fn get_show_broadcast(&self) -> bool {
        self.show_broadcast.unwrap_or(false)
    }
    pub fn clear_show_broadcast(&mut self) {
        self.show_broadcast = ::std::option::Option::None;
    }

    pub fn has_show_broadcast(&self) -> bool {
        self.show_broadcast.is_some()
    }

    // Param is passed by value, moved
    pub fn set_show_broadcast(&mut self, v: bool) {
        self.show_broadcast = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCuratorPreferences {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.supported_languages = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.platform_windows = ::std::option::Option::Some(tmp);
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.platform_mac = ::std::option::Option::Some(tmp);
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.platform_linux = ::std::option::Option::Some(tmp);
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.vr_content = ::std::option::Option::Some(tmp);
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.adult_content_violence = ::std::option::Option::Some(tmp);
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.adult_content_sex = ::std::option::Option::Some(tmp);
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.timestamp_updated = ::std::option::Option::Some(tmp);
                }
                9 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.tagids_curated)?;
                }
                10 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.tagids_filtered)?;
                }
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.website_title)?;
                }
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.website_url)?;
                }
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.discussion_url)?;
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.show_broadcast = ::std::option::Option::Some(tmp);
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.supported_languages {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.platform_windows {
            my_size += 2;
        }
        if let Some(v) = self.platform_mac {
            my_size += 2;
        }
        if let Some(v) = self.platform_linux {
            my_size += 2;
        }
        if let Some(v) = self.vr_content {
            my_size += 2;
        }
        if let Some(v) = self.adult_content_violence {
            my_size += 2;
        }
        if let Some(v) = self.adult_content_sex {
            my_size += 2;
        }
        if let Some(v) = self.timestamp_updated {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tagids_curated {
            my_size += ::protobuf::rt::value_size(9, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tagids_filtered {
            my_size += ::protobuf::rt::value_size(10, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.website_title.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.website_url.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.discussion_url.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(v) = self.show_broadcast {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.supported_languages {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.platform_windows {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.platform_mac {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.platform_linux {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.vr_content {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.adult_content_violence {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.adult_content_sex {
            os.write_bool(7, v)?;
        }
        if let Some(v) = self.timestamp_updated {
            os.write_uint32(8, v)?;
        }
        for v in &self.tagids_curated {
            os.write_uint32(9, *v)?;
        }
        for v in &self.tagids_filtered {
            os.write_uint32(10, *v)?;
        }
        if let Some(ref v) = self.website_title.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.website_url.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.discussion_url.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(v) = self.show_broadcast {
            os.write_bool(14, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCuratorPreferences {
        CCuratorPreferences::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "supported_languages",
                |m: &CCuratorPreferences| &m.supported_languages,
                |m: &mut CCuratorPreferences| &mut m.supported_languages,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "platform_windows",
                |m: &CCuratorPreferences| &m.platform_windows,
                |m: &mut CCuratorPreferences| &mut m.platform_windows,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "platform_mac",
                |m: &CCuratorPreferences| &m.platform_mac,
                |m: &mut CCuratorPreferences| &mut m.platform_mac,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "platform_linux",
                |m: &CCuratorPreferences| &m.platform_linux,
                |m: &mut CCuratorPreferences| &mut m.platform_linux,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "vr_content",
                |m: &CCuratorPreferences| &m.vr_content,
                |m: &mut CCuratorPreferences| &mut m.vr_content,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "adult_content_violence",
                |m: &CCuratorPreferences| &m.adult_content_violence,
                |m: &mut CCuratorPreferences| &mut m.adult_content_violence,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "adult_content_sex",
                |m: &CCuratorPreferences| &m.adult_content_sex,
                |m: &mut CCuratorPreferences| &mut m.adult_content_sex,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "timestamp_updated",
                |m: &CCuratorPreferences| &m.timestamp_updated,
                |m: &mut CCuratorPreferences| &mut m.timestamp_updated,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "tagids_curated",
                |m: &CCuratorPreferences| &m.tagids_curated,
                |m: &mut CCuratorPreferences| &mut m.tagids_curated,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "tagids_filtered",
                |m: &CCuratorPreferences| &m.tagids_filtered,
                |m: &mut CCuratorPreferences| &mut m.tagids_filtered,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "website_title",
                |m: &CCuratorPreferences| &m.website_title,
                |m: &mut CCuratorPreferences| &mut m.website_title,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "website_url",
                |m: &CCuratorPreferences| &m.website_url,
                |m: &mut CCuratorPreferences| &mut m.website_url,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "discussion_url",
                |m: &CCuratorPreferences| &m.discussion_url,
                |m: &mut CCuratorPreferences| &mut m.discussion_url,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "show_broadcast",
                |m: &CCuratorPreferences| &m.show_broadcast,
                |m: &mut CCuratorPreferences| &mut m.show_broadcast,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCuratorPreferences>(
                "CCuratorPreferences",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CCuratorPreferences {
        static instance: ::protobuf::rt::LazyV2<CCuratorPreferences> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCuratorPreferences::new)
    }
}

impl ::protobuf::Clear for CCuratorPreferences {
    fn clear(&mut self) {
        self.supported_languages = ::std::option::Option::None;
        self.platform_windows = ::std::option::Option::None;
        self.platform_mac = ::std::option::Option::None;
        self.platform_linux = ::std::option::Option::None;
        self.vr_content = ::std::option::Option::None;
        self.adult_content_violence = ::std::option::Option::None;
        self.adult_content_sex = ::std::option::Option::None;
        self.timestamp_updated = ::std::option::Option::None;
        self.tagids_curated.clear();
        self.tagids_filtered.clear();
        self.website_title.clear();
        self.website_url.clear();
        self.discussion_url.clear();
        self.show_broadcast = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCuratorPreferences {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCuratorPreferences {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CLocalizationToken {
    // message fields
    language: ::std::option::Option<u32>,
    localized_string: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CLocalizationToken {
    fn default() -> &'a CLocalizationToken {
        <CLocalizationToken as ::protobuf::Message>::default_instance()
    }
}

impl CLocalizationToken {
    pub fn new() -> CLocalizationToken {
        ::std::default::Default::default()
    }

    // optional uint32 language = 1;

    pub fn get_language(&self) -> u32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: u32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional string localized_string = 2;

    pub fn get_localized_string(&self) -> &str {
        match self.localized_string.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_localized_string(&mut self) {
        self.localized_string.clear();
    }

    pub fn has_localized_string(&self) -> bool {
        self.localized_string.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localized_string(&mut self, v: ::std::string::String) {
        self.localized_string = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localized_string(&mut self) -> &mut ::std::string::String {
        if self.localized_string.is_none() {
            self.localized_string.set_default();
        }
        self.localized_string.as_mut().unwrap()
    }

    // Take field
    pub fn take_localized_string(&mut self) -> ::std::string::String {
        self.localized_string
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CLocalizationToken {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.language = ::std::option::Option::Some(tmp);
                }
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localized_string)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.localized_string.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.language {
            os.write_uint32(1, v)?;
        }
        if let Some(ref v) = self.localized_string.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CLocalizationToken {
        CLocalizationToken::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "language",
                |m: &CLocalizationToken| &m.language,
                |m: &mut CLocalizationToken| &mut m.language,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "localized_string",
                |m: &CLocalizationToken| &m.localized_string,
                |m: &mut CLocalizationToken| &mut m.localized_string,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CLocalizationToken>(
                "CLocalizationToken",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CLocalizationToken {
        static instance: ::protobuf::rt::LazyV2<CLocalizationToken> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CLocalizationToken::new)
    }
}

impl ::protobuf::Clear for CLocalizationToken {
    fn clear(&mut self) {
        self.language = ::std::option::Option::None;
        self.localized_string.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CLocalizationToken {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CLocalizationToken {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClanEventUserNewsTuple {
    // message fields
    clanid: ::std::option::Option<u32>,
    event_gid: ::std::option::Option<u64>,
    announcement_gid: ::std::option::Option<u64>,
    rtime_start: ::std::option::Option<u32>,
    rtime_end: ::std::option::Option<u32>,
    priority_score: ::std::option::Option<u32>,
    field_type: ::std::option::Option<u32>,
    clamp_range_slot: ::std::option::Option<u32>,
    appid: ::std::option::Option<u32>,
    rtime32_last_modified: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanEventUserNewsTuple {
    fn default() -> &'a CClanEventUserNewsTuple {
        <CClanEventUserNewsTuple as ::protobuf::Message>::default_instance()
    }
}

impl CClanEventUserNewsTuple {
    pub fn new() -> CClanEventUserNewsTuple {
        ::std::default::Default::default()
    }

    // optional uint32 clanid = 1;

    pub fn get_clanid(&self) -> u32 {
        self.clanid.unwrap_or(0)
    }
    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u32) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 2;

    pub fn get_event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }
    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 announcement_gid = 3;

    pub fn get_announcement_gid(&self) -> u64 {
        self.announcement_gid.unwrap_or(0)
    }
    pub fn clear_announcement_gid(&mut self) {
        self.announcement_gid = ::std::option::Option::None;
    }

    pub fn has_announcement_gid(&self) -> bool {
        self.announcement_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_gid(&mut self, v: u64) {
        self.announcement_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_start = 4;

    pub fn get_rtime_start(&self) -> u32 {
        self.rtime_start.unwrap_or(0)
    }
    pub fn clear_rtime_start(&mut self) {
        self.rtime_start = ::std::option::Option::None;
    }

    pub fn has_rtime_start(&self) -> bool {
        self.rtime_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_start(&mut self, v: u32) {
        self.rtime_start = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_end = 5;

    pub fn get_rtime_end(&self) -> u32 {
        self.rtime_end.unwrap_or(0)
    }
    pub fn clear_rtime_end(&mut self) {
        self.rtime_end = ::std::option::Option::None;
    }

    pub fn has_rtime_end(&self) -> bool {
        self.rtime_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_end(&mut self, v: u32) {
        self.rtime_end = ::std::option::Option::Some(v);
    }

    // optional uint32 priority_score = 6;

    pub fn get_priority_score(&self) -> u32 {
        self.priority_score.unwrap_or(0)
    }
    pub fn clear_priority_score(&mut self) {
        self.priority_score = ::std::option::Option::None;
    }

    pub fn has_priority_score(&self) -> bool {
        self.priority_score.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority_score(&mut self, v: u32) {
        self.priority_score = ::std::option::Option::Some(v);
    }

    // optional uint32 type = 7;

    pub fn get_field_type(&self) -> u32 {
        self.field_type.unwrap_or(0)
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ::std::option::Option::None;
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: u32) {
        self.field_type = ::std::option::Option::Some(v);
    }

    // optional uint32 clamp_range_slot = 8;

    pub fn get_clamp_range_slot(&self) -> u32 {
        self.clamp_range_slot.unwrap_or(0)
    }
    pub fn clear_clamp_range_slot(&mut self) {
        self.clamp_range_slot = ::std::option::Option::None;
    }

    pub fn has_clamp_range_slot(&self) -> bool {
        self.clamp_range_slot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clamp_range_slot(&mut self, v: u32) {
        self.clamp_range_slot = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 9;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 10;

    pub fn get_rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0)
    }
    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CClanEventUserNewsTuple {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clanid = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.event_gid = ::std::option::Option::Some(tmp);
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.announcement_gid = ::std::option::Option::Some(tmp);
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime_start = ::std::option::Option::Some(tmp);
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime_end = ::std::option::Option::Some(tmp);
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.priority_score = ::std::option::Option::Some(tmp);
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.field_type = ::std::option::Option::Some(tmp);
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.clamp_range_slot = ::std::option::Option::Some(tmp);
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_last_modified = ::std::option::Option::Some(tmp);
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.event_gid {
            my_size += 9;
        }
        if let Some(v) = self.announcement_gid {
            my_size += 9;
        }
        if let Some(v) = self.rtime_start {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime_end {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.priority_score {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.field_type {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.clamp_range_slot {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.clanid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(2, v)?;
        }
        if let Some(v) = self.announcement_gid {
            os.write_fixed64(3, v)?;
        }
        if let Some(v) = self.rtime_start {
            os.write_uint32(4, v)?;
        }
        if let Some(v) = self.rtime_end {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.priority_score {
            os.write_uint32(6, v)?;
        }
        if let Some(v) = self.field_type {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.clamp_range_slot {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanEventUserNewsTuple {
        CClanEventUserNewsTuple::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "clanid",
                |m: &CClanEventUserNewsTuple| &m.clanid,
                |m: &mut CClanEventUserNewsTuple| &mut m.clanid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "event_gid",
                |m: &CClanEventUserNewsTuple| &m.event_gid,
                |m: &mut CClanEventUserNewsTuple| &mut m.event_gid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "announcement_gid",
                |m: &CClanEventUserNewsTuple| &m.announcement_gid,
                |m: &mut CClanEventUserNewsTuple| &mut m.announcement_gid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime_start",
                |m: &CClanEventUserNewsTuple| &m.rtime_start,
                |m: &mut CClanEventUserNewsTuple| &mut m.rtime_start,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime_end",
                |m: &CClanEventUserNewsTuple| &m.rtime_end,
                |m: &mut CClanEventUserNewsTuple| &mut m.rtime_end,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "priority_score",
                |m: &CClanEventUserNewsTuple| &m.priority_score,
                |m: &mut CClanEventUserNewsTuple| &mut m.priority_score,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "type",
                |m: &CClanEventUserNewsTuple| &m.field_type,
                |m: &mut CClanEventUserNewsTuple| &mut m.field_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "clamp_range_slot",
                |m: &CClanEventUserNewsTuple| &m.clamp_range_slot,
                |m: &mut CClanEventUserNewsTuple| &mut m.clamp_range_slot,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "appid",
                |m: &CClanEventUserNewsTuple| &m.appid,
                |m: &mut CClanEventUserNewsTuple| &mut m.appid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime32_last_modified",
                |m: &CClanEventUserNewsTuple| &m.rtime32_last_modified,
                |m: &mut CClanEventUserNewsTuple| &mut m.rtime32_last_modified,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClanEventUserNewsTuple>(
                "CClanEventUserNewsTuple",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CClanEventUserNewsTuple {
        static instance: ::protobuf::rt::LazyV2<CClanEventUserNewsTuple> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClanEventUserNewsTuple::new)
    }
}

impl ::protobuf::Clear for CClanEventUserNewsTuple {
    fn clear(&mut self) {
        self.clanid = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.announcement_gid = ::std::option::Option::None;
        self.rtime_start = ::std::option::Option::None;
        self.rtime_end = ::std::option::Option::None;
        self.priority_score = ::std::option::Option::None;
        self.field_type = ::std::option::Option::None;
        self.clamp_range_slot = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanEventUserNewsTuple {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanEventUserNewsTuple {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClanMatchEventByRange {
    // message fields
    rtime_before: ::std::option::Option<u32>,
    rtime_after: ::std::option::Option<u32>,
    qualified: ::std::option::Option<u32>,
    pub events: ::protobuf::RepeatedField<CClanEventUserNewsTuple>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanMatchEventByRange {
    fn default() -> &'a CClanMatchEventByRange {
        <CClanMatchEventByRange as ::protobuf::Message>::default_instance()
    }
}

impl CClanMatchEventByRange {
    pub fn new() -> CClanMatchEventByRange {
        ::std::default::Default::default()
    }

    // optional uint32 rtime_before = 1;

    pub fn get_rtime_before(&self) -> u32 {
        self.rtime_before.unwrap_or(0)
    }
    pub fn clear_rtime_before(&mut self) {
        self.rtime_before = ::std::option::Option::None;
    }

    pub fn has_rtime_before(&self) -> bool {
        self.rtime_before.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_before(&mut self, v: u32) {
        self.rtime_before = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_after = 2;

    pub fn get_rtime_after(&self) -> u32 {
        self.rtime_after.unwrap_or(0)
    }
    pub fn clear_rtime_after(&mut self) {
        self.rtime_after = ::std::option::Option::None;
    }

    pub fn has_rtime_after(&self) -> bool {
        self.rtime_after.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_after(&mut self, v: u32) {
        self.rtime_after = ::std::option::Option::Some(v);
    }

    // optional uint32 qualified = 3;

    pub fn get_qualified(&self) -> u32 {
        self.qualified.unwrap_or(0)
    }
    pub fn clear_qualified(&mut self) {
        self.qualified = ::std::option::Option::None;
    }

    pub fn has_qualified(&self) -> bool {
        self.qualified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qualified(&mut self, v: u32) {
        self.qualified = ::std::option::Option::Some(v);
    }

    // repeated .CClanEventUserNewsTuple events = 4;

    pub fn get_events(&self) -> &[CClanEventUserNewsTuple] {
        &self.events
    }
    pub fn clear_events(&mut self) {
        self.events.clear();
    }

    // Param is passed by value, moved
    pub fn set_events(&mut self, v: ::protobuf::RepeatedField<CClanEventUserNewsTuple>) {
        self.events = v;
    }

    // Mutable pointer to the field.
    pub fn mut_events(&mut self) -> &mut ::protobuf::RepeatedField<CClanEventUserNewsTuple> {
        &mut self.events
    }

    // Take field
    pub fn take_events(&mut self) -> ::protobuf::RepeatedField<CClanEventUserNewsTuple> {
        ::std::mem::replace(&mut self.events, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for CClanMatchEventByRange {
    fn is_initialized(&self) -> bool {
        for v in &self.events {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime_before = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime_after = ::std::option::Option::Some(tmp);
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.qualified = ::std::option::Option::Some(tmp);
                }
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.events)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.rtime_before {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime_after {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.qualified {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.events {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.rtime_before {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.rtime_after {
            os.write_uint32(2, v)?;
        }
        if let Some(v) = self.qualified {
            os.write_uint32(3, v)?;
        }
        for v in &self.events {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanMatchEventByRange {
        CClanMatchEventByRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime_before",
                |m: &CClanMatchEventByRange| &m.rtime_before,
                |m: &mut CClanMatchEventByRange| &mut m.rtime_before,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime_after",
                |m: &CClanMatchEventByRange| &m.rtime_after,
                |m: &mut CClanMatchEventByRange| &mut m.rtime_after,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "qualified",
                |m: &CClanMatchEventByRange| &m.qualified,
                |m: &mut CClanMatchEventByRange| &mut m.qualified,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeMessage<CClanEventUserNewsTuple>,
            >(
                "events",
                |m: &CClanMatchEventByRange| &m.events,
                |m: &mut CClanMatchEventByRange| &mut m.events,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClanMatchEventByRange>(
                "CClanMatchEventByRange",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CClanMatchEventByRange {
        static instance: ::protobuf::rt::LazyV2<CClanMatchEventByRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClanMatchEventByRange::new)
    }
}

impl ::protobuf::Clear for CClanMatchEventByRange {
    fn clear(&mut self) {
        self.rtime_before = ::std::option::Option::None;
        self.rtime_after = ::std::option::Option::None;
        self.qualified = ::std::option::Option::None;
        self.events.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanMatchEventByRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanMatchEventByRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CCommunity_ClanAnnouncementInfo {
    // message fields
    gid: ::std::option::Option<u64>,
    clanid: ::std::option::Option<u64>,
    posterid: ::std::option::Option<u64>,
    headline: ::protobuf::SingularField<::std::string::String>,
    posttime: ::std::option::Option<u32>,
    updatetime: ::std::option::Option<u32>,
    body: ::protobuf::SingularField<::std::string::String>,
    commentcount: ::std::option::Option<i32>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    language: ::std::option::Option<i32>,
    hidden: ::std::option::Option<bool>,
    forum_topic_id: ::std::option::Option<u64>,
    event_gid: ::std::option::Option<u64>,
    voteupcount: ::std::option::Option<i32>,
    votedowncount: ::std::option::Option<i32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CCommunity_ClanAnnouncementInfo {
    fn default() -> &'a CCommunity_ClanAnnouncementInfo {
        <CCommunity_ClanAnnouncementInfo as ::protobuf::Message>::default_instance()
    }
}

impl CCommunity_ClanAnnouncementInfo {
    pub fn new() -> CCommunity_ClanAnnouncementInfo {
        ::std::default::Default::default()
    }

    // optional uint64 gid = 1;

    pub fn get_gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }
    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional uint64 clanid = 2;

    pub fn get_clanid(&self) -> u64 {
        self.clanid.unwrap_or(0)
    }
    pub fn clear_clanid(&mut self) {
        self.clanid = ::std::option::Option::None;
    }

    pub fn has_clanid(&self) -> bool {
        self.clanid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clanid(&mut self, v: u64) {
        self.clanid = ::std::option::Option::Some(v);
    }

    // optional uint64 posterid = 3;

    pub fn get_posterid(&self) -> u64 {
        self.posterid.unwrap_or(0)
    }
    pub fn clear_posterid(&mut self) {
        self.posterid = ::std::option::Option::None;
    }

    pub fn has_posterid(&self) -> bool {
        self.posterid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posterid(&mut self, v: u64) {
        self.posterid = ::std::option::Option::Some(v);
    }

    // optional string headline = 4;

    pub fn get_headline(&self) -> &str {
        match self.headline.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_headline(&mut self) {
        self.headline.clear();
    }

    pub fn has_headline(&self) -> bool {
        self.headline.is_some()
    }

    // Param is passed by value, moved
    pub fn set_headline(&mut self, v: ::std::string::String) {
        self.headline = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_headline(&mut self) -> &mut ::std::string::String {
        if self.headline.is_none() {
            self.headline.set_default();
        }
        self.headline.as_mut().unwrap()
    }

    // Take field
    pub fn take_headline(&mut self) -> ::std::string::String {
        self.headline.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 posttime = 5;

    pub fn get_posttime(&self) -> u32 {
        self.posttime.unwrap_or(0)
    }
    pub fn clear_posttime(&mut self) {
        self.posttime = ::std::option::Option::None;
    }

    pub fn has_posttime(&self) -> bool {
        self.posttime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_posttime(&mut self, v: u32) {
        self.posttime = ::std::option::Option::Some(v);
    }

    // optional uint32 updatetime = 6;

    pub fn get_updatetime(&self) -> u32 {
        self.updatetime.unwrap_or(0)
    }
    pub fn clear_updatetime(&mut self) {
        self.updatetime = ::std::option::Option::None;
    }

    pub fn has_updatetime(&self) -> bool {
        self.updatetime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_updatetime(&mut self, v: u32) {
        self.updatetime = ::std::option::Option::Some(v);
    }

    // optional string body = 7;

    pub fn get_body(&self) -> &str {
        match self.body.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    pub fn has_body(&self) -> bool {
        self.body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::string::String) {
        self.body = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::string::String {
        if self.body.is_none() {
            self.body.set_default();
        }
        self.body.as_mut().unwrap()
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::string::String {
        self.body.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 commentcount = 8;

    pub fn get_commentcount(&self) -> i32 {
        self.commentcount.unwrap_or(0)
    }
    pub fn clear_commentcount(&mut self) {
        self.commentcount = ::std::option::Option::None;
    }

    pub fn has_commentcount(&self) -> bool {
        self.commentcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commentcount(&mut self, v: i32) {
        self.commentcount = ::std::option::Option::Some(v);
    }

    // repeated string tags = 9;

    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // optional int32 language = 10;

    pub fn get_language(&self) -> i32 {
        self.language.unwrap_or(0)
    }
    pub fn clear_language(&mut self) {
        self.language = ::std::option::Option::None;
    }

    pub fn has_language(&self) -> bool {
        self.language.is_some()
    }

    // Param is passed by value, moved
    pub fn set_language(&mut self, v: i32) {
        self.language = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 11;

    pub fn get_hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }
    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 12;

    pub fn get_forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }
    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    // optional fixed64 event_gid = 13;

    pub fn get_event_gid(&self) -> u64 {
        self.event_gid.unwrap_or(0)
    }
    pub fn clear_event_gid(&mut self) {
        self.event_gid = ::std::option::Option::None;
    }

    pub fn has_event_gid(&self) -> bool {
        self.event_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_gid(&mut self, v: u64) {
        self.event_gid = ::std::option::Option::Some(v);
    }

    // optional int32 voteupcount = 14;

    pub fn get_voteupcount(&self) -> i32 {
        self.voteupcount.unwrap_or(0)
    }
    pub fn clear_voteupcount(&mut self) {
        self.voteupcount = ::std::option::Option::None;
    }

    pub fn has_voteupcount(&self) -> bool {
        self.voteupcount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_voteupcount(&mut self, v: i32) {
        self.voteupcount = ::std::option::Option::Some(v);
    }

    // optional int32 votedowncount = 15;

    pub fn get_votedowncount(&self) -> i32 {
        self.votedowncount.unwrap_or(0)
    }
    pub fn clear_votedowncount(&mut self) {
        self.votedowncount = ::std::option::Option::None;
    }

    pub fn has_votedowncount(&self) -> bool {
        self.votedowncount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_votedowncount(&mut self, v: i32) {
        self.votedowncount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CCommunity_ClanAnnouncementInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.gid = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.clanid = ::std::option::Option::Some(tmp);
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint64()?;
                    self.posterid = ::std::option::Option::Some(tmp);
                }
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.headline)?;
                }
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.posttime = ::std::option::Option::Some(tmp);
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.updatetime = ::std::option::Option::Some(tmp);
                }
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.body)?;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.commentcount = ::std::option::Option::Some(tmp);
                }
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.language = ::std::option::Option::Some(tmp);
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = ::std::option::Option::Some(tmp);
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.forum_topic_id = ::std::option::Option::Some(tmp);
                }
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.event_gid = ::std::option::Option::Some(tmp);
                }
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.voteupcount = ::std::option::Option::Some(tmp);
                }
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.votedowncount = ::std::option::Option::Some(tmp);
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.clanid {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.posterid {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.headline.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.posttime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.updatetime {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.body.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.commentcount {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(9, &value);
        }
        if let Some(v) = self.language {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.hidden {
            my_size += 2;
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 9;
        }
        if let Some(v) = self.event_gid {
            my_size += 9;
        }
        if let Some(v) = self.voteupcount {
            my_size += ::protobuf::rt::value_size(14, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.votedowncount {
            my_size += ::protobuf::rt::value_size(15, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gid {
            os.write_uint64(1, v)?;
        }
        if let Some(v) = self.clanid {
            os.write_uint64(2, v)?;
        }
        if let Some(v) = self.posterid {
            os.write_uint64(3, v)?;
        }
        if let Some(ref v) = self.headline.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.posttime {
            os.write_uint32(5, v)?;
        }
        if let Some(v) = self.updatetime {
            os.write_uint32(6, v)?;
        }
        if let Some(ref v) = self.body.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.commentcount {
            os.write_int32(8, v)?;
        }
        for v in &self.tags {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.language {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(12, v)?;
        }
        if let Some(v) = self.event_gid {
            os.write_fixed64(13, v)?;
        }
        if let Some(v) = self.voteupcount {
            os.write_int32(14, v)?;
        }
        if let Some(v) = self.votedowncount {
            os.write_int32(15, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CCommunity_ClanAnnouncementInfo {
        CCommunity_ClanAnnouncementInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "gid",
                |m: &CCommunity_ClanAnnouncementInfo| &m.gid,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.gid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "clanid",
                |m: &CCommunity_ClanAnnouncementInfo| &m.clanid,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.clanid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint64,
            >(
                "posterid",
                |m: &CCommunity_ClanAnnouncementInfo| &m.posterid,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.posterid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "headline",
                |m: &CCommunity_ClanAnnouncementInfo| &m.headline,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.headline,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "posttime",
                |m: &CCommunity_ClanAnnouncementInfo| &m.posttime,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.posttime,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "updatetime",
                |m: &CCommunity_ClanAnnouncementInfo| &m.updatetime,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.updatetime,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "body",
                |m: &CCommunity_ClanAnnouncementInfo| &m.body,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.body,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "commentcount",
                |m: &CCommunity_ClanAnnouncementInfo| &m.commentcount,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.commentcount,
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "tags",
                |m: &CCommunity_ClanAnnouncementInfo| &m.tags,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.tags,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "language",
                |m: &CCommunity_ClanAnnouncementInfo| &m.language,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.language,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "hidden",
                |m: &CCommunity_ClanAnnouncementInfo| &m.hidden,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.hidden,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "forum_topic_id",
                |m: &CCommunity_ClanAnnouncementInfo| &m.forum_topic_id,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.forum_topic_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "event_gid",
                |m: &CCommunity_ClanAnnouncementInfo| &m.event_gid,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.event_gid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "voteupcount",
                |m: &CCommunity_ClanAnnouncementInfo| &m.voteupcount,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.voteupcount,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "votedowncount",
                |m: &CCommunity_ClanAnnouncementInfo| &m.votedowncount,
                |m: &mut CCommunity_ClanAnnouncementInfo| &mut m.votedowncount,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CCommunity_ClanAnnouncementInfo>(
                "CCommunity_ClanAnnouncementInfo",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CCommunity_ClanAnnouncementInfo {
        static instance: ::protobuf::rt::LazyV2<CCommunity_ClanAnnouncementInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CCommunity_ClanAnnouncementInfo::new)
    }
}

impl ::protobuf::Clear for CCommunity_ClanAnnouncementInfo {
    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clanid = ::std::option::Option::None;
        self.posterid = ::std::option::Option::None;
        self.headline.clear();
        self.posttime = ::std::option::Option::None;
        self.updatetime = ::std::option::Option::None;
        self.body.clear();
        self.commentcount = ::std::option::Option::None;
        self.tags.clear();
        self.language = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.event_gid = ::std::option::Option::None;
        self.voteupcount = ::std::option::Option::None;
        self.votedowncount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CCommunity_ClanAnnouncementInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CCommunity_ClanAnnouncementInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CClanEventData {
    // message fields
    gid: ::std::option::Option<u64>,
    clan_steamid: ::std::option::Option<u64>,
    event_name: ::protobuf::SingularField<::std::string::String>,
    event_type: ::std::option::Option<EProtoClanEventType>,
    appid: ::std::option::Option<u32>,
    server_address: ::protobuf::SingularField<::std::string::String>,
    server_password: ::protobuf::SingularField<::std::string::String>,
    rtime32_start_time: ::std::option::Option<u32>,
    rtime32_end_time: ::std::option::Option<u32>,
    comment_count: ::std::option::Option<i32>,
    creator_steamid: ::std::option::Option<u64>,
    last_update_steamid: ::std::option::Option<u64>,
    event_notes: ::protobuf::SingularField<::std::string::String>,
    jsondata: ::protobuf::SingularField<::std::string::String>,
    pub announcement_body: ::protobuf::SingularPtrField<CCommunity_ClanAnnouncementInfo>,
    published: ::std::option::Option<bool>,
    hidden: ::std::option::Option<bool>,
    rtime32_visibility_start: ::std::option::Option<u32>,
    rtime32_visibility_end: ::std::option::Option<u32>,
    broadcaster_accountid: ::std::option::Option<u32>,
    follower_count: ::std::option::Option<u32>,
    ignore_count: ::std::option::Option<u32>,
    forum_topic_id: ::std::option::Option<u64>,
    rtime32_last_modified: ::std::option::Option<u32>,
    news_post_gid: ::std::option::Option<u64>,
    rtime_mod_reviewed: ::std::option::Option<u32>,
    featured_app_tagid: ::std::option::Option<u32>,
    pub referenced_appids: ::std::vec::Vec<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CClanEventData {
    fn default() -> &'a CClanEventData {
        <CClanEventData as ::protobuf::Message>::default_instance()
    }
}

impl CClanEventData {
    pub fn new() -> CClanEventData {
        ::std::default::Default::default()
    }

    // optional fixed64 gid = 1;

    pub fn get_gid(&self) -> u64 {
        self.gid.unwrap_or(0)
    }
    pub fn clear_gid(&mut self) {
        self.gid = ::std::option::Option::None;
    }

    pub fn has_gid(&self) -> bool {
        self.gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gid(&mut self, v: u64) {
        self.gid = ::std::option::Option::Some(v);
    }

    // optional fixed64 clan_steamid = 2;

    pub fn get_clan_steamid(&self) -> u64 {
        self.clan_steamid.unwrap_or(0)
    }
    pub fn clear_clan_steamid(&mut self) {
        self.clan_steamid = ::std::option::Option::None;
    }

    pub fn has_clan_steamid(&self) -> bool {
        self.clan_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clan_steamid(&mut self, v: u64) {
        self.clan_steamid = ::std::option::Option::Some(v);
    }

    // optional string event_name = 3;

    pub fn get_event_name(&self) -> &str {
        match self.event_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_event_name(&mut self) {
        self.event_name.clear();
    }

    pub fn has_event_name(&self) -> bool {
        self.event_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_name(&mut self, v: ::std::string::String) {
        self.event_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_name(&mut self) -> &mut ::std::string::String {
        if self.event_name.is_none() {
            self.event_name.set_default();
        }
        self.event_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_name(&mut self) -> ::std::string::String {
        self.event_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .EProtoClanEventType event_type = 4;

    pub fn get_event_type(&self) -> EProtoClanEventType {
        self.event_type.unwrap_or(EProtoClanEventType::k_EClanOtherEvent)
    }
    pub fn clear_event_type(&mut self) {
        self.event_type = ::std::option::Option::None;
    }

    pub fn has_event_type(&self) -> bool {
        self.event_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_type(&mut self, v: EProtoClanEventType) {
        self.event_type = ::std::option::Option::Some(v);
    }

    // optional uint32 appid = 5;

    pub fn get_appid(&self) -> u32 {
        self.appid.unwrap_or(0)
    }
    pub fn clear_appid(&mut self) {
        self.appid = ::std::option::Option::None;
    }

    pub fn has_appid(&self) -> bool {
        self.appid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appid(&mut self, v: u32) {
        self.appid = ::std::option::Option::Some(v);
    }

    // optional string server_address = 6;

    pub fn get_server_address(&self) -> &str {
        match self.server_address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_server_address(&mut self) {
        self.server_address.clear();
    }

    pub fn has_server_address(&self) -> bool {
        self.server_address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_address(&mut self, v: ::std::string::String) {
        self.server_address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_address(&mut self) -> &mut ::std::string::String {
        if self.server_address.is_none() {
            self.server_address.set_default();
        }
        self.server_address.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_address(&mut self) -> ::std::string::String {
        self.server_address
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string server_password = 7;

    pub fn get_server_password(&self) -> &str {
        match self.server_password.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_server_password(&mut self) {
        self.server_password.clear();
    }

    pub fn has_server_password(&self) -> bool {
        self.server_password.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server_password(&mut self, v: ::std::string::String) {
        self.server_password = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server_password(&mut self) -> &mut ::std::string::String {
        if self.server_password.is_none() {
            self.server_password.set_default();
        }
        self.server_password.as_mut().unwrap()
    }

    // Take field
    pub fn take_server_password(&mut self) -> ::std::string::String {
        self.server_password
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }

    // optional uint32 rtime32_start_time = 8;

    pub fn get_rtime32_start_time(&self) -> u32 {
        self.rtime32_start_time.unwrap_or(0)
    }
    pub fn clear_rtime32_start_time(&mut self) {
        self.rtime32_start_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_start_time(&self) -> bool {
        self.rtime32_start_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_start_time(&mut self, v: u32) {
        self.rtime32_start_time = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_end_time = 9;

    pub fn get_rtime32_end_time(&self) -> u32 {
        self.rtime32_end_time.unwrap_or(0)
    }
    pub fn clear_rtime32_end_time(&mut self) {
        self.rtime32_end_time = ::std::option::Option::None;
    }

    pub fn has_rtime32_end_time(&self) -> bool {
        self.rtime32_end_time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_end_time(&mut self, v: u32) {
        self.rtime32_end_time = ::std::option::Option::Some(v);
    }

    // optional int32 comment_count = 10;

    pub fn get_comment_count(&self) -> i32 {
        self.comment_count.unwrap_or(0)
    }
    pub fn clear_comment_count(&mut self) {
        self.comment_count = ::std::option::Option::None;
    }

    pub fn has_comment_count(&self) -> bool {
        self.comment_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_comment_count(&mut self, v: i32) {
        self.comment_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 creator_steamid = 11;

    pub fn get_creator_steamid(&self) -> u64 {
        self.creator_steamid.unwrap_or(0)
    }
    pub fn clear_creator_steamid(&mut self) {
        self.creator_steamid = ::std::option::Option::None;
    }

    pub fn has_creator_steamid(&self) -> bool {
        self.creator_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creator_steamid(&mut self, v: u64) {
        self.creator_steamid = ::std::option::Option::Some(v);
    }

    // optional fixed64 last_update_steamid = 12;

    pub fn get_last_update_steamid(&self) -> u64 {
        self.last_update_steamid.unwrap_or(0)
    }
    pub fn clear_last_update_steamid(&mut self) {
        self.last_update_steamid = ::std::option::Option::None;
    }

    pub fn has_last_update_steamid(&self) -> bool {
        self.last_update_steamid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_update_steamid(&mut self, v: u64) {
        self.last_update_steamid = ::std::option::Option::Some(v);
    }

    // optional string event_notes = 13;

    pub fn get_event_notes(&self) -> &str {
        match self.event_notes.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_event_notes(&mut self) {
        self.event_notes.clear();
    }

    pub fn has_event_notes(&self) -> bool {
        self.event_notes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_event_notes(&mut self, v: ::std::string::String) {
        self.event_notes = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_event_notes(&mut self) -> &mut ::std::string::String {
        if self.event_notes.is_none() {
            self.event_notes.set_default();
        }
        self.event_notes.as_mut().unwrap()
    }

    // Take field
    pub fn take_event_notes(&mut self) -> ::std::string::String {
        self.event_notes.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string jsondata = 14;

    pub fn get_jsondata(&self) -> &str {
        match self.jsondata.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_jsondata(&mut self) {
        self.jsondata.clear();
    }

    pub fn has_jsondata(&self) -> bool {
        self.jsondata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_jsondata(&mut self, v: ::std::string::String) {
        self.jsondata = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_jsondata(&mut self) -> &mut ::std::string::String {
        if self.jsondata.is_none() {
            self.jsondata.set_default();
        }
        self.jsondata.as_mut().unwrap()
    }

    // Take field
    pub fn take_jsondata(&mut self) -> ::std::string::String {
        self.jsondata.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .CCommunity_ClanAnnouncementInfo announcement_body = 15;

    pub fn get_announcement_body(&self) -> &CCommunity_ClanAnnouncementInfo {
        self.announcement_body
            .as_ref()
            .unwrap_or_else(|| <CCommunity_ClanAnnouncementInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_announcement_body(&mut self) {
        self.announcement_body.clear();
    }

    pub fn has_announcement_body(&self) -> bool {
        self.announcement_body.is_some()
    }

    // Param is passed by value, moved
    pub fn set_announcement_body(&mut self, v: CCommunity_ClanAnnouncementInfo) {
        self.announcement_body = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_announcement_body(&mut self) -> &mut CCommunity_ClanAnnouncementInfo {
        if self.announcement_body.is_none() {
            self.announcement_body.set_default();
        }
        self.announcement_body.as_mut().unwrap()
    }

    // Take field
    pub fn take_announcement_body(&mut self) -> CCommunity_ClanAnnouncementInfo {
        self.announcement_body
            .take()
            .unwrap_or_else(|| CCommunity_ClanAnnouncementInfo::new())
    }

    // optional bool published = 16;

    pub fn get_published(&self) -> bool {
        self.published.unwrap_or(false)
    }
    pub fn clear_published(&mut self) {
        self.published = ::std::option::Option::None;
    }

    pub fn has_published(&self) -> bool {
        self.published.is_some()
    }

    // Param is passed by value, moved
    pub fn set_published(&mut self, v: bool) {
        self.published = ::std::option::Option::Some(v);
    }

    // optional bool hidden = 17;

    pub fn get_hidden(&self) -> bool {
        self.hidden.unwrap_or(false)
    }
    pub fn clear_hidden(&mut self) {
        self.hidden = ::std::option::Option::None;
    }

    pub fn has_hidden(&self) -> bool {
        self.hidden.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hidden(&mut self, v: bool) {
        self.hidden = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_visibility_start = 18;

    pub fn get_rtime32_visibility_start(&self) -> u32 {
        self.rtime32_visibility_start.unwrap_or(0)
    }
    pub fn clear_rtime32_visibility_start(&mut self) {
        self.rtime32_visibility_start = ::std::option::Option::None;
    }

    pub fn has_rtime32_visibility_start(&self) -> bool {
        self.rtime32_visibility_start.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_visibility_start(&mut self, v: u32) {
        self.rtime32_visibility_start = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_visibility_end = 19;

    pub fn get_rtime32_visibility_end(&self) -> u32 {
        self.rtime32_visibility_end.unwrap_or(0)
    }
    pub fn clear_rtime32_visibility_end(&mut self) {
        self.rtime32_visibility_end = ::std::option::Option::None;
    }

    pub fn has_rtime32_visibility_end(&self) -> bool {
        self.rtime32_visibility_end.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_visibility_end(&mut self, v: u32) {
        self.rtime32_visibility_end = ::std::option::Option::Some(v);
    }

    // optional uint32 broadcaster_accountid = 20;

    pub fn get_broadcaster_accountid(&self) -> u32 {
        self.broadcaster_accountid.unwrap_or(0)
    }
    pub fn clear_broadcaster_accountid(&mut self) {
        self.broadcaster_accountid = ::std::option::Option::None;
    }

    pub fn has_broadcaster_accountid(&self) -> bool {
        self.broadcaster_accountid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_broadcaster_accountid(&mut self, v: u32) {
        self.broadcaster_accountid = ::std::option::Option::Some(v);
    }

    // optional uint32 follower_count = 21;

    pub fn get_follower_count(&self) -> u32 {
        self.follower_count.unwrap_or(0)
    }
    pub fn clear_follower_count(&mut self) {
        self.follower_count = ::std::option::Option::None;
    }

    pub fn has_follower_count(&self) -> bool {
        self.follower_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follower_count(&mut self, v: u32) {
        self.follower_count = ::std::option::Option::Some(v);
    }

    // optional uint32 ignore_count = 22;

    pub fn get_ignore_count(&self) -> u32 {
        self.ignore_count.unwrap_or(0)
    }
    pub fn clear_ignore_count(&mut self) {
        self.ignore_count = ::std::option::Option::None;
    }

    pub fn has_ignore_count(&self) -> bool {
        self.ignore_count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ignore_count(&mut self, v: u32) {
        self.ignore_count = ::std::option::Option::Some(v);
    }

    // optional fixed64 forum_topic_id = 23;

    pub fn get_forum_topic_id(&self) -> u64 {
        self.forum_topic_id.unwrap_or(0)
    }
    pub fn clear_forum_topic_id(&mut self) {
        self.forum_topic_id = ::std::option::Option::None;
    }

    pub fn has_forum_topic_id(&self) -> bool {
        self.forum_topic_id.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forum_topic_id(&mut self, v: u64) {
        self.forum_topic_id = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime32_last_modified = 24;

    pub fn get_rtime32_last_modified(&self) -> u32 {
        self.rtime32_last_modified.unwrap_or(0)
    }
    pub fn clear_rtime32_last_modified(&mut self) {
        self.rtime32_last_modified = ::std::option::Option::None;
    }

    pub fn has_rtime32_last_modified(&self) -> bool {
        self.rtime32_last_modified.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime32_last_modified(&mut self, v: u32) {
        self.rtime32_last_modified = ::std::option::Option::Some(v);
    }

    // optional fixed64 news_post_gid = 25;

    pub fn get_news_post_gid(&self) -> u64 {
        self.news_post_gid.unwrap_or(0)
    }
    pub fn clear_news_post_gid(&mut self) {
        self.news_post_gid = ::std::option::Option::None;
    }

    pub fn has_news_post_gid(&self) -> bool {
        self.news_post_gid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_news_post_gid(&mut self, v: u64) {
        self.news_post_gid = ::std::option::Option::Some(v);
    }

    // optional uint32 rtime_mod_reviewed = 26;

    pub fn get_rtime_mod_reviewed(&self) -> u32 {
        self.rtime_mod_reviewed.unwrap_or(0)
    }
    pub fn clear_rtime_mod_reviewed(&mut self) {
        self.rtime_mod_reviewed = ::std::option::Option::None;
    }

    pub fn has_rtime_mod_reviewed(&self) -> bool {
        self.rtime_mod_reviewed.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rtime_mod_reviewed(&mut self, v: u32) {
        self.rtime_mod_reviewed = ::std::option::Option::Some(v);
    }

    // optional uint32 featured_app_tagid = 27;

    pub fn get_featured_app_tagid(&self) -> u32 {
        self.featured_app_tagid.unwrap_or(0)
    }
    pub fn clear_featured_app_tagid(&mut self) {
        self.featured_app_tagid = ::std::option::Option::None;
    }

    pub fn has_featured_app_tagid(&self) -> bool {
        self.featured_app_tagid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_featured_app_tagid(&mut self, v: u32) {
        self.featured_app_tagid = ::std::option::Option::Some(v);
    }

    // repeated uint32 referenced_appids = 28;

    pub fn get_referenced_appids(&self) -> &[u32] {
        &self.referenced_appids
    }
    pub fn clear_referenced_appids(&mut self) {
        self.referenced_appids.clear();
    }

    // Param is passed by value, moved
    pub fn set_referenced_appids(&mut self, v: ::std::vec::Vec<u32>) {
        self.referenced_appids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_referenced_appids(&mut self) -> &mut ::std::vec::Vec<u32> {
        &mut self.referenced_appids
    }

    // Take field
    pub fn take_referenced_appids(&mut self) -> ::std::vec::Vec<u32> {
        ::std::mem::replace(&mut self.referenced_appids, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for CClanEventData {
    fn is_initialized(&self) -> bool {
        for v in &self.announcement_body {
            if !v.is_initialized() {
                return false;
            }
        }
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.gid = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.clan_steamid = ::std::option::Option::Some(tmp);
                }
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_name)?;
                }
                4 => ::protobuf::rt::read_proto2_enum_with_unknown_fields_into(
                    wire_type,
                    is,
                    &mut self.event_type,
                    4,
                    &mut self.unknown_fields,
                )?,
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.appid = ::std::option::Option::Some(tmp);
                }
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_address)?;
                }
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server_password)?;
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_start_time = ::std::option::Option::Some(tmp);
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_end_time = ::std::option::Option::Some(tmp);
                }
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.comment_count = ::std::option::Option::Some(tmp);
                }
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.creator_steamid = ::std::option::Option::Some(tmp);
                }
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.last_update_steamid = ::std::option::Option::Some(tmp);
                }
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.event_notes)?;
                }
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.jsondata)?;
                }
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.announcement_body)?;
                }
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.published = ::std::option::Option::Some(tmp);
                }
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hidden = ::std::option::Option::Some(tmp);
                }
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_visibility_start = ::std::option::Option::Some(tmp);
                }
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_visibility_end = ::std::option::Option::Some(tmp);
                }
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.broadcaster_accountid = ::std::option::Option::Some(tmp);
                }
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.follower_count = ::std::option::Option::Some(tmp);
                }
                22 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.ignore_count = ::std::option::Option::Some(tmp);
                }
                23 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.forum_topic_id = ::std::option::Option::Some(tmp);
                }
                24 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime32_last_modified = ::std::option::Option::Some(tmp);
                }
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_fixed64()?;
                    self.news_post_gid = ::std::option::Option::Some(tmp);
                }
                26 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.rtime_mod_reviewed = ::std::option::Option::Some(tmp);
                }
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.featured_app_tagid = ::std::option::Option::Some(tmp);
                }
                28 => {
                    ::protobuf::rt::read_repeated_uint32_into(wire_type, is, &mut self.referenced_appids)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gid {
            my_size += 9;
        }
        if let Some(v) = self.clan_steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.event_name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.event_type {
            my_size += ::protobuf::rt::enum_size(4, v);
        }
        if let Some(v) = self.appid {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.server_address.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.server_password.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(v) = self.rtime32_start_time {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime32_end_time {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.comment_count {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.creator_steamid {
            my_size += 9;
        }
        if let Some(v) = self.last_update_steamid {
            my_size += 9;
        }
        if let Some(ref v) = self.event_notes.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.jsondata.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.announcement_body.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.published {
            my_size += 3;
        }
        if let Some(v) = self.hidden {
            my_size += 3;
        }
        if let Some(v) = self.rtime32_visibility_start {
            my_size += ::protobuf::rt::value_size(18, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.rtime32_visibility_end {
            my_size += ::protobuf::rt::value_size(19, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.broadcaster_accountid {
            my_size += ::protobuf::rt::value_size(20, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.follower_count {
            my_size += ::protobuf::rt::value_size(21, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.ignore_count {
            my_size += ::protobuf::rt::value_size(22, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.forum_topic_id {
            my_size += 10;
        }
        if let Some(v) = self.rtime32_last_modified {
            my_size += ::protobuf::rt::value_size(24, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.news_post_gid {
            my_size += 10;
        }
        if let Some(v) = self.rtime_mod_reviewed {
            my_size += ::protobuf::rt::value_size(26, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.featured_app_tagid {
            my_size += ::protobuf::rt::value_size(27, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.referenced_appids {
            my_size += ::protobuf::rt::value_size(28, *value, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gid {
            os.write_fixed64(1, v)?;
        }
        if let Some(v) = self.clan_steamid {
            os.write_fixed64(2, v)?;
        }
        if let Some(ref v) = self.event_name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.event_type {
            os.write_enum(4, ::protobuf::ProtobufEnum::value(&v))?;
        }
        if let Some(v) = self.appid {
            os.write_uint32(5, v)?;
        }
        if let Some(ref v) = self.server_address.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.server_password.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(v) = self.rtime32_start_time {
            os.write_uint32(8, v)?;
        }
        if let Some(v) = self.rtime32_end_time {
            os.write_uint32(9, v)?;
        }
        if let Some(v) = self.comment_count {
            os.write_int32(10, v)?;
        }
        if let Some(v) = self.creator_steamid {
            os.write_fixed64(11, v)?;
        }
        if let Some(v) = self.last_update_steamid {
            os.write_fixed64(12, v)?;
        }
        if let Some(ref v) = self.event_notes.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.jsondata.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.announcement_body.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.published {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.hidden {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.rtime32_visibility_start {
            os.write_uint32(18, v)?;
        }
        if let Some(v) = self.rtime32_visibility_end {
            os.write_uint32(19, v)?;
        }
        if let Some(v) = self.broadcaster_accountid {
            os.write_uint32(20, v)?;
        }
        if let Some(v) = self.follower_count {
            os.write_uint32(21, v)?;
        }
        if let Some(v) = self.ignore_count {
            os.write_uint32(22, v)?;
        }
        if let Some(v) = self.forum_topic_id {
            os.write_fixed64(23, v)?;
        }
        if let Some(v) = self.rtime32_last_modified {
            os.write_uint32(24, v)?;
        }
        if let Some(v) = self.news_post_gid {
            os.write_fixed64(25, v)?;
        }
        if let Some(v) = self.rtime_mod_reviewed {
            os.write_uint32(26, v)?;
        }
        if let Some(v) = self.featured_app_tagid {
            os.write_uint32(27, v)?;
        }
        for v in &self.referenced_appids {
            os.write_uint32(28, *v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CClanEventData {
        CClanEventData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "gid",
                |m: &CClanEventData| &m.gid,
                |m: &mut CClanEventData| &mut m.gid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "clan_steamid",
                |m: &CClanEventData| &m.clan_steamid,
                |m: &mut CClanEventData| &mut m.clan_steamid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "event_name",
                |m: &CClanEventData| &m.event_name,
                |m: &mut CClanEventData| &mut m.event_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeEnum<EProtoClanEventType>,
            >(
                "event_type",
                |m: &CClanEventData| &m.event_type,
                |m: &mut CClanEventData| &mut m.event_type,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "appid",
                |m: &CClanEventData| &m.appid,
                |m: &mut CClanEventData| &mut m.appid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "server_address",
                |m: &CClanEventData| &m.server_address,
                |m: &mut CClanEventData| &mut m.server_address,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "server_password",
                |m: &CClanEventData| &m.server_password,
                |m: &mut CClanEventData| &mut m.server_password,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime32_start_time",
                |m: &CClanEventData| &m.rtime32_start_time,
                |m: &mut CClanEventData| &mut m.rtime32_start_time,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime32_end_time",
                |m: &CClanEventData| &m.rtime32_end_time,
                |m: &mut CClanEventData| &mut m.rtime32_end_time,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "comment_count",
                |m: &CClanEventData| &m.comment_count,
                |m: &mut CClanEventData| &mut m.comment_count,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "creator_steamid",
                |m: &CClanEventData| &m.creator_steamid,
                |m: &mut CClanEventData| &mut m.creator_steamid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "last_update_steamid",
                |m: &CClanEventData| &m.last_update_steamid,
                |m: &mut CClanEventData| &mut m.last_update_steamid,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "event_notes",
                |m: &CClanEventData| &m.event_notes,
                |m: &mut CClanEventData| &mut m.event_notes,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "jsondata",
                |m: &CClanEventData| &m.jsondata,
                |m: &mut CClanEventData| &mut m.jsondata,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeMessage<CCommunity_ClanAnnouncementInfo>,
            >(
                "announcement_body",
                |m: &CClanEventData| &m.announcement_body,
                |m: &mut CClanEventData| &mut m.announcement_body,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "published",
                |m: &CClanEventData| &m.published,
                |m: &mut CClanEventData| &mut m.published,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "hidden",
                |m: &CClanEventData| &m.hidden,
                |m: &mut CClanEventData| &mut m.hidden,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime32_visibility_start",
                |m: &CClanEventData| &m.rtime32_visibility_start,
                |m: &mut CClanEventData| &mut m.rtime32_visibility_start,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime32_visibility_end",
                |m: &CClanEventData| &m.rtime32_visibility_end,
                |m: &mut CClanEventData| &mut m.rtime32_visibility_end,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "broadcaster_accountid",
                |m: &CClanEventData| &m.broadcaster_accountid,
                |m: &mut CClanEventData| &mut m.broadcaster_accountid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "follower_count",
                |m: &CClanEventData| &m.follower_count,
                |m: &mut CClanEventData| &mut m.follower_count,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "ignore_count",
                |m: &CClanEventData| &m.ignore_count,
                |m: &mut CClanEventData| &mut m.ignore_count,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "forum_topic_id",
                |m: &CClanEventData| &m.forum_topic_id,
                |m: &mut CClanEventData| &mut m.forum_topic_id,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime32_last_modified",
                |m: &CClanEventData| &m.rtime32_last_modified,
                |m: &mut CClanEventData| &mut m.rtime32_last_modified,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeFixed64,
            >(
                "news_post_gid",
                |m: &CClanEventData| &m.news_post_gid,
                |m: &mut CClanEventData| &mut m.news_post_gid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "rtime_mod_reviewed",
                |m: &CClanEventData| &m.rtime_mod_reviewed,
                |m: &mut CClanEventData| &mut m.rtime_mod_reviewed,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "featured_app_tagid",
                |m: &CClanEventData| &m.featured_app_tagid,
                |m: &mut CClanEventData| &mut m.featured_app_tagid,
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "referenced_appids",
                |m: &CClanEventData| &m.referenced_appids,
                |m: &mut CClanEventData| &mut m.referenced_appids,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CClanEventData>(
                "CClanEventData",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CClanEventData {
        static instance: ::protobuf::rt::LazyV2<CClanEventData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CClanEventData::new)
    }
}

impl ::protobuf::Clear for CClanEventData {
    fn clear(&mut self) {
        self.gid = ::std::option::Option::None;
        self.clan_steamid = ::std::option::Option::None;
        self.event_name.clear();
        self.event_type = ::std::option::Option::None;
        self.appid = ::std::option::Option::None;
        self.server_address.clear();
        self.server_password.clear();
        self.rtime32_start_time = ::std::option::Option::None;
        self.rtime32_end_time = ::std::option::Option::None;
        self.comment_count = ::std::option::Option::None;
        self.creator_steamid = ::std::option::Option::None;
        self.last_update_steamid = ::std::option::Option::None;
        self.event_notes.clear();
        self.jsondata.clear();
        self.announcement_body.clear();
        self.published = ::std::option::Option::None;
        self.hidden = ::std::option::Option::None;
        self.rtime32_visibility_start = ::std::option::Option::None;
        self.rtime32_visibility_end = ::std::option::Option::None;
        self.broadcaster_accountid = ::std::option::Option::None;
        self.follower_count = ::std::option::Option::None;
        self.ignore_count = ::std::option::Option::None;
        self.forum_topic_id = ::std::option::Option::None;
        self.rtime32_last_modified = ::std::option::Option::None;
        self.news_post_gid = ::std::option::Option::None;
        self.rtime_mod_reviewed = ::std::option::Option::None;
        self.featured_app_tagid = ::std::option::Option::None;
        self.referenced_appids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CClanEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CClanEventData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CBilling_Address {
    // message fields
    first_name: ::protobuf::SingularField<::std::string::String>,
    last_name: ::protobuf::SingularField<::std::string::String>,
    address1: ::protobuf::SingularField<::std::string::String>,
    address2: ::protobuf::SingularField<::std::string::String>,
    city: ::protobuf::SingularField<::std::string::String>,
    us_state: ::protobuf::SingularField<::std::string::String>,
    country_code: ::protobuf::SingularField<::std::string::String>,
    postcode: ::protobuf::SingularField<::std::string::String>,
    zip_plus4: ::std::option::Option<i32>,
    phone: ::protobuf::SingularField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CBilling_Address {
    fn default() -> &'a CBilling_Address {
        <CBilling_Address as ::protobuf::Message>::default_instance()
    }
}

impl CBilling_Address {
    pub fn new() -> CBilling_Address {
        ::std::default::Default::default()
    }

    // optional string first_name = 1;

    pub fn get_first_name(&self) -> &str {
        match self.first_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_first_name(&mut self) {
        self.first_name.clear();
    }

    pub fn has_first_name(&self) -> bool {
        self.first_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_first_name(&mut self, v: ::std::string::String) {
        self.first_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_first_name(&mut self) -> &mut ::std::string::String {
        if self.first_name.is_none() {
            self.first_name.set_default();
        }
        self.first_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_first_name(&mut self) -> ::std::string::String {
        self.first_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string last_name = 2;

    pub fn get_last_name(&self) -> &str {
        match self.last_name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_last_name(&mut self) {
        self.last_name.clear();
    }

    pub fn has_last_name(&self) -> bool {
        self.last_name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_last_name(&mut self, v: ::std::string::String) {
        self.last_name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_last_name(&mut self) -> &mut ::std::string::String {
        if self.last_name.is_none() {
            self.last_name.set_default();
        }
        self.last_name.as_mut().unwrap()
    }

    // Take field
    pub fn take_last_name(&mut self) -> ::std::string::String {
        self.last_name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address1 = 3;

    pub fn get_address1(&self) -> &str {
        match self.address1.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address1(&mut self) {
        self.address1.clear();
    }

    pub fn has_address1(&self) -> bool {
        self.address1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address1(&mut self, v: ::std::string::String) {
        self.address1 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address1(&mut self) -> &mut ::std::string::String {
        if self.address1.is_none() {
            self.address1.set_default();
        }
        self.address1.as_mut().unwrap()
    }

    // Take field
    pub fn take_address1(&mut self) -> ::std::string::String {
        self.address1.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address2 = 4;

    pub fn get_address2(&self) -> &str {
        match self.address2.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address2(&mut self) {
        self.address2.clear();
    }

    pub fn has_address2(&self) -> bool {
        self.address2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address2(&mut self, v: ::std::string::String) {
        self.address2 = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address2(&mut self) -> &mut ::std::string::String {
        if self.address2.is_none() {
            self.address2.set_default();
        }
        self.address2.as_mut().unwrap()
    }

    // Take field
    pub fn take_address2(&mut self) -> ::std::string::String {
        self.address2.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string city = 5;

    pub fn get_city(&self) -> &str {
        match self.city.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_city(&mut self) {
        self.city.clear();
    }

    pub fn has_city(&self) -> bool {
        self.city.is_some()
    }

    // Param is passed by value, moved
    pub fn set_city(&mut self, v: ::std::string::String) {
        self.city = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_city(&mut self) -> &mut ::std::string::String {
        if self.city.is_none() {
            self.city.set_default();
        }
        self.city.as_mut().unwrap()
    }

    // Take field
    pub fn take_city(&mut self) -> ::std::string::String {
        self.city.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string us_state = 6;

    pub fn get_us_state(&self) -> &str {
        match self.us_state.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_us_state(&mut self) {
        self.us_state.clear();
    }

    pub fn has_us_state(&self) -> bool {
        self.us_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_us_state(&mut self, v: ::std::string::String) {
        self.us_state = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_us_state(&mut self) -> &mut ::std::string::String {
        if self.us_state.is_none() {
            self.us_state.set_default();
        }
        self.us_state.as_mut().unwrap()
    }

    // Take field
    pub fn take_us_state(&mut self) -> ::std::string::String {
        self.us_state.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string country_code = 7;

    pub fn get_country_code(&self) -> &str {
        match self.country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_country_code(&mut self) {
        self.country_code.clear();
    }

    pub fn has_country_code(&self) -> bool {
        self.country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_country_code(&mut self, v: ::std::string::String) {
        self.country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_country_code(&mut self) -> &mut ::std::string::String {
        if self.country_code.is_none() {
            self.country_code.set_default();
        }
        self.country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_country_code(&mut self) -> ::std::string::String {
        self.country_code.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string postcode = 8;

    pub fn get_postcode(&self) -> &str {
        match self.postcode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_postcode(&mut self) {
        self.postcode.clear();
    }

    pub fn has_postcode(&self) -> bool {
        self.postcode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postcode(&mut self, v: ::std::string::String) {
        self.postcode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postcode(&mut self) -> &mut ::std::string::String {
        if self.postcode.is_none() {
            self.postcode.set_default();
        }
        self.postcode.as_mut().unwrap()
    }

    // Take field
    pub fn take_postcode(&mut self) -> ::std::string::String {
        self.postcode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 zip_plus4 = 9;

    pub fn get_zip_plus4(&self) -> i32 {
        self.zip_plus4.unwrap_or(0)
    }
    pub fn clear_zip_plus4(&mut self) {
        self.zip_plus4 = ::std::option::Option::None;
    }

    pub fn has_zip_plus4(&self) -> bool {
        self.zip_plus4.is_some()
    }

    // Param is passed by value, moved
    pub fn set_zip_plus4(&mut self, v: i32) {
        self.zip_plus4 = ::std::option::Option::Some(v);
    }

    // optional string phone = 10;

    pub fn get_phone(&self) -> &str {
        match self.phone.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_phone(&mut self) {
        self.phone.clear();
    }

    pub fn has_phone(&self) -> bool {
        self.phone.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phone(&mut self, v: ::std::string::String) {
        self.phone = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phone(&mut self) -> &mut ::std::string::String {
        if self.phone.is_none() {
            self.phone.set_default();
        }
        self.phone.as_mut().unwrap()
    }

    // Take field
    pub fn take_phone(&mut self) -> ::std::string::String {
        self.phone.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CBilling_Address {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.first_name)?;
                }
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.last_name)?;
                }
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address1)?;
                }
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address2)?;
                }
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.city)?;
                }
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.us_state)?;
                }
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.country_code)?;
                }
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.postcode)?;
                }
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.zip_plus4 = ::std::option::Option::Some(tmp);
                }
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phone)?;
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.first_name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.last_name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.address1.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.address2.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.city.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.us_state.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.postcode.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.zip_plus4 {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.phone.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.first_name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.last_name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.address1.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.address2.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.city.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.us_state.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.country_code.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.postcode.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.zip_plus4 {
            os.write_int32(9, v)?;
        }
        if let Some(ref v) = self.phone.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CBilling_Address {
        CBilling_Address::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "first_name",
                |m: &CBilling_Address| &m.first_name,
                |m: &mut CBilling_Address| &mut m.first_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "last_name",
                |m: &CBilling_Address| &m.last_name,
                |m: &mut CBilling_Address| &mut m.last_name,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "address1",
                |m: &CBilling_Address| &m.address1,
                |m: &mut CBilling_Address| &mut m.address1,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "address2",
                |m: &CBilling_Address| &m.address2,
                |m: &mut CBilling_Address| &mut m.address2,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "city",
                |m: &CBilling_Address| &m.city,
                |m: &mut CBilling_Address| &mut m.city,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "us_state",
                |m: &CBilling_Address| &m.us_state,
                |m: &mut CBilling_Address| &mut m.us_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "country_code",
                |m: &CBilling_Address| &m.country_code,
                |m: &mut CBilling_Address| &mut m.country_code,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "postcode",
                |m: &CBilling_Address| &m.postcode,
                |m: &mut CBilling_Address| &mut m.postcode,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "zip_plus4",
                |m: &CBilling_Address| &m.zip_plus4,
                |m: &mut CBilling_Address| &mut m.zip_plus4,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "phone",
                |m: &CBilling_Address| &m.phone,
                |m: &mut CBilling_Address| &mut m.phone,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CBilling_Address>(
                "CBilling_Address",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CBilling_Address {
        static instance: ::protobuf::rt::LazyV2<CBilling_Address> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CBilling_Address::new)
    }
}

impl ::protobuf::Clear for CBilling_Address {
    fn clear(&mut self) {
        self.first_name.clear();
        self.last_name.clear();
        self.address1.clear();
        self.address2.clear();
        self.city.clear();
        self.us_state.clear();
        self.country_code.clear();
        self.postcode.clear();
        self.zip_plus4 = ::std::option::Option::None;
        self.phone.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CBilling_Address {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CBilling_Address {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq, Clone, Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CPackageReservationStatus {
    // message fields
    packageid: ::std::option::Option<u32>,
    reservation_state: ::std::option::Option<i32>,
    queue_position: ::std::option::Option<i32>,
    total_queue_size: ::std::option::Option<i32>,
    reservation_country_code: ::protobuf::SingularField<::std::string::String>,
    expired: ::std::option::Option<bool>,
    time_expires: ::std::option::Option<u32>,
    time_reserved: ::std::option::Option<u32>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CPackageReservationStatus {
    fn default() -> &'a CPackageReservationStatus {
        <CPackageReservationStatus as ::protobuf::Message>::default_instance()
    }
}

impl CPackageReservationStatus {
    pub fn new() -> CPackageReservationStatus {
        ::std::default::Default::default()
    }

    // optional uint32 packageid = 1;

    pub fn get_packageid(&self) -> u32 {
        self.packageid.unwrap_or(0)
    }
    pub fn clear_packageid(&mut self) {
        self.packageid = ::std::option::Option::None;
    }

    pub fn has_packageid(&self) -> bool {
        self.packageid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_packageid(&mut self, v: u32) {
        self.packageid = ::std::option::Option::Some(v);
    }

    // optional int32 reservation_state = 2;

    pub fn get_reservation_state(&self) -> i32 {
        self.reservation_state.unwrap_or(0)
    }
    pub fn clear_reservation_state(&mut self) {
        self.reservation_state = ::std::option::Option::None;
    }

    pub fn has_reservation_state(&self) -> bool {
        self.reservation_state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_state(&mut self, v: i32) {
        self.reservation_state = ::std::option::Option::Some(v);
    }

    // optional int32 queue_position = 3;

    pub fn get_queue_position(&self) -> i32 {
        self.queue_position.unwrap_or(0)
    }
    pub fn clear_queue_position(&mut self) {
        self.queue_position = ::std::option::Option::None;
    }

    pub fn has_queue_position(&self) -> bool {
        self.queue_position.is_some()
    }

    // Param is passed by value, moved
    pub fn set_queue_position(&mut self, v: i32) {
        self.queue_position = ::std::option::Option::Some(v);
    }

    // optional int32 total_queue_size = 4;

    pub fn get_total_queue_size(&self) -> i32 {
        self.total_queue_size.unwrap_or(0)
    }
    pub fn clear_total_queue_size(&mut self) {
        self.total_queue_size = ::std::option::Option::None;
    }

    pub fn has_total_queue_size(&self) -> bool {
        self.total_queue_size.is_some()
    }

    // Param is passed by value, moved
    pub fn set_total_queue_size(&mut self, v: i32) {
        self.total_queue_size = ::std::option::Option::Some(v);
    }

    // optional string reservation_country_code = 5;

    pub fn get_reservation_country_code(&self) -> &str {
        match self.reservation_country_code.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reservation_country_code(&mut self) {
        self.reservation_country_code.clear();
    }

    pub fn has_reservation_country_code(&self) -> bool {
        self.reservation_country_code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reservation_country_code(&mut self, v: ::std::string::String) {
        self.reservation_country_code = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reservation_country_code(&mut self) -> &mut ::std::string::String {
        if self.reservation_country_code.is_none() {
            self.reservation_country_code.set_default();
        }
        self.reservation_country_code.as_mut().unwrap()
    }

    // Take field
    pub fn take_reservation_country_code(&mut self) -> ::std::string::String {
        self.reservation_country_code
            .take()
            .unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool expired = 6;

    pub fn get_expired(&self) -> bool {
        self.expired.unwrap_or(false)
    }
    pub fn clear_expired(&mut self) {
        self.expired = ::std::option::Option::None;
    }

    pub fn has_expired(&self) -> bool {
        self.expired.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expired(&mut self, v: bool) {
        self.expired = ::std::option::Option::Some(v);
    }

    // optional uint32 time_expires = 7;

    pub fn get_time_expires(&self) -> u32 {
        self.time_expires.unwrap_or(0)
    }
    pub fn clear_time_expires(&mut self) {
        self.time_expires = ::std::option::Option::None;
    }

    pub fn has_time_expires(&self) -> bool {
        self.time_expires.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_expires(&mut self, v: u32) {
        self.time_expires = ::std::option::Option::Some(v);
    }

    // optional uint32 time_reserved = 8;

    pub fn get_time_reserved(&self) -> u32 {
        self.time_reserved.unwrap_or(0)
    }
    pub fn clear_time_reserved(&mut self) {
        self.time_reserved = ::std::option::Option::None;
    }

    pub fn has_time_reserved(&self) -> bool {
        self.time_reserved.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time_reserved(&mut self, v: u32) {
        self.time_reserved = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CPackageReservationStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.packageid = ::std::option::Option::Some(tmp);
                }
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.reservation_state = ::std::option::Option::Some(tmp);
                }
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.queue_position = ::std::option::Option::Some(tmp);
                }
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.total_queue_size = ::std::option::Option::Some(tmp);
                }
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reservation_country_code)?;
                }
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.expired = ::std::option::Option::Some(tmp);
                }
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_expires = ::std::option::Option::Some(tmp);
                }
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.time_reserved = ::std::option::Option::Some(tmp);
                }
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                }
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.packageid {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.reservation_state {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.queue_position {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.total_queue_size {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reservation_country_code.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.expired {
            my_size += 2;
        }
        if let Some(v) = self.time_expires {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.time_reserved {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.packageid {
            os.write_uint32(1, v)?;
        }
        if let Some(v) = self.reservation_state {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.queue_position {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.total_queue_size {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.reservation_country_code.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.expired {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.time_expires {
            os.write_uint32(7, v)?;
        }
        if let Some(v) = self.time_reserved {
            os.write_uint32(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CPackageReservationStatus {
        CPackageReservationStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> =
            ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "packageid",
                |m: &CPackageReservationStatus| &m.packageid,
                |m: &mut CPackageReservationStatus| &mut m.packageid,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "reservation_state",
                |m: &CPackageReservationStatus| &m.reservation_state,
                |m: &mut CPackageReservationStatus| &mut m.reservation_state,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "queue_position",
                |m: &CPackageReservationStatus| &m.queue_position,
                |m: &mut CPackageReservationStatus| &mut m.queue_position,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeInt32,
            >(
                "total_queue_size",
                |m: &CPackageReservationStatus| &m.total_queue_size,
                |m: &mut CPackageReservationStatus| &mut m.total_queue_size,
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<
                _,
                ::protobuf::types::ProtobufTypeString,
            >(
                "reservation_country_code",
                |m: &CPackageReservationStatus| &m.reservation_country_code,
                |m: &mut CPackageReservationStatus| &mut m.reservation_country_code,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeBool,
            >(
                "expired",
                |m: &CPackageReservationStatus| &m.expired,
                |m: &mut CPackageReservationStatus| &mut m.expired,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "time_expires",
                |m: &CPackageReservationStatus| &m.time_expires,
                |m: &mut CPackageReservationStatus| &mut m.time_expires,
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<
                _,
                ::protobuf::types::ProtobufTypeUint32,
            >(
                "time_reserved",
                |m: &CPackageReservationStatus| &m.time_reserved,
                |m: &mut CPackageReservationStatus| &mut m.time_reserved,
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CPackageReservationStatus>(
                "CPackageReservationStatus",
                fields,
                file_descriptor_proto(),
            )
        })
    }

    fn default_instance() -> &'static CPackageReservationStatus {
        static instance: ::protobuf::rt::LazyV2<CPackageReservationStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CPackageReservationStatus::new)
    }
}

impl ::protobuf::Clear for CPackageReservationStatus {
    fn clear(&mut self) {
        self.packageid = ::std::option::Option::None;
        self.reservation_state = ::std::option::Option::None;
        self.queue_position = ::std::option::Option::None;
        self.total_queue_size = ::std::option::Option::None;
        self.reservation_country_code.clear();
        self.expired = ::std::option::Option::None;
        self.time_expires = ::std::option::Option::None;
        self.time_reserved = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CPackageReservationStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CPackageReservationStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum EProtoClanEventType {
    k_EClanOtherEvent = 1,
    k_EClanGameEvent = 2,
    k_EClanPartyEvent = 3,
    k_EClanMeetingEvent = 4,
    k_EClanSpecialCauseEvent = 5,
    k_EClanMusicAndArtsEvent = 6,
    k_EClanSportsEvent = 7,
    k_EClanTripEvent = 8,
    k_EClanChatEvent = 9,
    k_EClanGameReleaseEvent = 10,
    k_EClanBroadcastEvent = 11,
    k_EClanSmallUpdateEvent = 12,
    k_EClanPreAnnounceMajorUpdateEvent = 13,
    k_EClanMajorUpdateEvent = 14,
    k_EClanDLCReleaseEvent = 15,
    k_EClanFutureReleaseEvent = 16,
    k_EClanESportTournamentStreamEvent = 17,
    k_EClanDevStreamEvent = 18,
    k_EClanFamousStreamEvent = 19,
    k_EClanGameSalesEvent = 20,
    k_EClanGameItemSalesEvent = 21,
    k_EClanInGameBonusXPEvent = 22,
    k_EClanInGameLootEvent = 23,
    k_EClanInGamePerksEvent = 24,
    k_EClanInGameChallengeEvent = 25,
    k_EClanInGameContestEvent = 26,
    k_EClanIRLEvent = 27,
    k_EClanNewsEvent = 28,
    k_EClanBetaReleaseEvent = 29,
    k_EClanInGameContentReleaseEvent = 30,
    k_EClanFreeTrial = 31,
    k_EClanSeasonRelease = 32,
    k_EClanSeasonUpdate = 33,
    k_EClanCrosspostEvent = 34,
    k_EClanInGameEventGeneral = 35,
}

impl ::protobuf::ProtobufEnum for EProtoClanEventType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EProtoClanEventType> {
        match value {
            1 => ::std::option::Option::Some(EProtoClanEventType::k_EClanOtherEvent),
            2 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameEvent),
            3 => ::std::option::Option::Some(EProtoClanEventType::k_EClanPartyEvent),
            4 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMeetingEvent),
            5 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSpecialCauseEvent),
            6 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMusicAndArtsEvent),
            7 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSportsEvent),
            8 => ::std::option::Option::Some(EProtoClanEventType::k_EClanTripEvent),
            9 => ::std::option::Option::Some(EProtoClanEventType::k_EClanChatEvent),
            10 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameReleaseEvent),
            11 => ::std::option::Option::Some(EProtoClanEventType::k_EClanBroadcastEvent),
            12 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSmallUpdateEvent),
            13 => ::std::option::Option::Some(EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent),
            14 => ::std::option::Option::Some(EProtoClanEventType::k_EClanMajorUpdateEvent),
            15 => ::std::option::Option::Some(EProtoClanEventType::k_EClanDLCReleaseEvent),
            16 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFutureReleaseEvent),
            17 => ::std::option::Option::Some(EProtoClanEventType::k_EClanESportTournamentStreamEvent),
            18 => ::std::option::Option::Some(EProtoClanEventType::k_EClanDevStreamEvent),
            19 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFamousStreamEvent),
            20 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameSalesEvent),
            21 => ::std::option::Option::Some(EProtoClanEventType::k_EClanGameItemSalesEvent),
            22 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameBonusXPEvent),
            23 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameLootEvent),
            24 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGamePerksEvent),
            25 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameChallengeEvent),
            26 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContestEvent),
            27 => ::std::option::Option::Some(EProtoClanEventType::k_EClanIRLEvent),
            28 => ::std::option::Option::Some(EProtoClanEventType::k_EClanNewsEvent),
            29 => ::std::option::Option::Some(EProtoClanEventType::k_EClanBetaReleaseEvent),
            30 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameContentReleaseEvent),
            31 => ::std::option::Option::Some(EProtoClanEventType::k_EClanFreeTrial),
            32 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonRelease),
            33 => ::std::option::Option::Some(EProtoClanEventType::k_EClanSeasonUpdate),
            34 => ::std::option::Option::Some(EProtoClanEventType::k_EClanCrosspostEvent),
            35 => ::std::option::Option::Some(EProtoClanEventType::k_EClanInGameEventGeneral),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [EProtoClanEventType] = &[
            EProtoClanEventType::k_EClanOtherEvent,
            EProtoClanEventType::k_EClanGameEvent,
            EProtoClanEventType::k_EClanPartyEvent,
            EProtoClanEventType::k_EClanMeetingEvent,
            EProtoClanEventType::k_EClanSpecialCauseEvent,
            EProtoClanEventType::k_EClanMusicAndArtsEvent,
            EProtoClanEventType::k_EClanSportsEvent,
            EProtoClanEventType::k_EClanTripEvent,
            EProtoClanEventType::k_EClanChatEvent,
            EProtoClanEventType::k_EClanGameReleaseEvent,
            EProtoClanEventType::k_EClanBroadcastEvent,
            EProtoClanEventType::k_EClanSmallUpdateEvent,
            EProtoClanEventType::k_EClanPreAnnounceMajorUpdateEvent,
            EProtoClanEventType::k_EClanMajorUpdateEvent,
            EProtoClanEventType::k_EClanDLCReleaseEvent,
            EProtoClanEventType::k_EClanFutureReleaseEvent,
            EProtoClanEventType::k_EClanESportTournamentStreamEvent,
            EProtoClanEventType::k_EClanDevStreamEvent,
            EProtoClanEventType::k_EClanFamousStreamEvent,
            EProtoClanEventType::k_EClanGameSalesEvent,
            EProtoClanEventType::k_EClanGameItemSalesEvent,
            EProtoClanEventType::k_EClanInGameBonusXPEvent,
            EProtoClanEventType::k_EClanInGameLootEvent,
            EProtoClanEventType::k_EClanInGamePerksEvent,
            EProtoClanEventType::k_EClanInGameChallengeEvent,
            EProtoClanEventType::k_EClanInGameContestEvent,
            EProtoClanEventType::k_EClanIRLEvent,
            EProtoClanEventType::k_EClanNewsEvent,
            EProtoClanEventType::k_EClanBetaReleaseEvent,
            EProtoClanEventType::k_EClanInGameContentReleaseEvent,
            EProtoClanEventType::k_EClanFreeTrial,
            EProtoClanEventType::k_EClanSeasonRelease,
            EProtoClanEventType::k_EClanSeasonUpdate,
            EProtoClanEventType::k_EClanCrosspostEvent,
            EProtoClanEventType::k_EClanInGameEventGeneral,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<EProtoClanEventType>(
                "EProtoClanEventType",
                file_descriptor_proto(),
            )
        })
    }
}

impl ::std::marker::Copy for EProtoClanEventType {}

// Note, `Default` is implemented although default value is not 0
impl ::std::default::Default for EProtoClanEventType {
    fn default() -> Self {
        EProtoClanEventType::k_EClanOtherEvent
    }
}

impl ::protobuf::reflect::ProtobufValue for EProtoClanEventType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

#[derive(Clone, PartialEq, Eq, Debug, Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub enum PartnerEventNotificationType {
    k_EEventStart = 0,
    k_EEventBroadcastStart = 1,
    k_EEventMatchStart = 2,
    k_EEventPartnerMaxType = 3,
}

impl ::protobuf::ProtobufEnum for PartnerEventNotificationType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PartnerEventNotificationType> {
        match value {
            0 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventStart),
            1 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventBroadcastStart),
            2 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventMatchStart),
            3 => ::std::option::Option::Some(PartnerEventNotificationType::k_EEventPartnerMaxType),
            _ => ::std::option::Option::None,
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PartnerEventNotificationType] = &[
            PartnerEventNotificationType::k_EEventStart,
            PartnerEventNotificationType::k_EEventBroadcastStart,
            PartnerEventNotificationType::k_EEventMatchStart,
            PartnerEventNotificationType::k_EEventPartnerMaxType,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            ::protobuf::reflect::EnumDescriptor::new_pb_name::<PartnerEventNotificationType>(
                "PartnerEventNotificationType",
                file_descriptor_proto(),
            )
        })
    }
}

impl ::std::marker::Copy for PartnerEventNotificationType {}

impl ::std::default::Default for PartnerEventNotificationType {
    fn default() -> Self {
        PartnerEventNotificationType::k_EEventStart
    }
}

impl ::protobuf::reflect::ProtobufValue for PartnerEventNotificationType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(::protobuf::ProtobufEnum::descriptor(self))
    }
}

/// Extension fields
pub mod exts {

    pub const msgpool_soft_limit: ::protobuf::ext::ExtFieldOptional<
        ::protobuf::descriptor::MessageOptions,
        ::protobuf::types::ProtobufTypeInt32,
    > = ::protobuf::ext::ExtFieldOptional {
        field_number: 50000,
        phantom: ::std::marker::PhantomData,
    };

    pub const msgpool_hard_limit: ::protobuf::ext::ExtFieldOptional<
        ::protobuf::descriptor::MessageOptions,
        ::protobuf::types::ProtobufTypeInt32,
    > = ::protobuf::ext::ExtFieldOptional {
        field_number: 50001,
        phantom: ::std::marker::PhantomData,
    };

    pub const force_php_generation: ::protobuf::ext::ExtFieldOptional<
        ::protobuf::descriptor::FileOptions,
        ::protobuf::types::ProtobufTypeBool,
    > = ::protobuf::ext::ExtFieldOptional {
        field_number: 50000,
        phantom: ::std::marker::PhantomData,
    };

    pub const php_output_always_number: ::protobuf::ext::ExtFieldOptional<
        ::protobuf::descriptor::FieldOptions,
        ::protobuf::types::ProtobufTypeBool,
    > = ::protobuf::ext::ExtFieldOptional {
        field_number: 50020,
        phantom: ::std::marker::PhantomData,
    };
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x18steammessages_base.proto\x1a\x20google/protobuf/descriptor.proto\"\
    9\n\rCMsgIPAddress\x12\x10\n\x02v4\x18\x01\x20\x01(\x07H\0R\x02v4\x12\
    \x10\n\x02v6\x18\x02\x20\x01(\x0cH\0R\x02v6B\x04\n\x02ip\"m\n\x13CMsgIPA\
    ddressBucket\x12>\n\x13original_ip_address\x18\x01\x20\x01(\x0b2\x0e.CMs\
    gIPAddressR\x11originalIpAddress\x12\x16\n\x06bucket\x18\x02\x20\x01(\
    \x06R\x06bucket\"\xe5\x07\n\x12CMsgProtoBufHeader\x12\x18\n\x07steamid\
    \x18\x01\x20\x01(\x06R\x07steamid\x12)\n\x10client_sessionid\x18\x02\x20\
    \x01(\x05R\x0fclientSessionid\x12#\n\rrouting_appid\x18\x03\x20\x01(\rR\
    \x0croutingAppid\x127\n\x0cjobid_source\x18\n\x20\x01(\x06:\x14184467440\
    73709551615R\x0bjobidSource\x127\n\x0cjobid_target\x18\x0b\x20\x01(\x06:\
    \x1418446744073709551615R\x0bjobidTarget\x12&\n\x0ftarget_job_name\x18\
    \x0c\x20\x01(\tR\rtargetJobName\x12\x17\n\x07seq_num\x18\x18\x20\x01(\
    \x05R\x06seqNum\x12\x1b\n\x07eresult\x18\r\x20\x01(\x05:\x012R\x07eresul\
    t\x12#\n\rerror_message\x18\x0e\x20\x01(\tR\x0cerrorMessage\x12,\n\x12au\
    th_account_flags\x18\x10\x20\x01(\rR\x10authAccountFlags\x12!\n\x0ctoken\
    _source\x18\x16\x20\x01(\rR\x0btokenSource\x12.\n\x13admin_spoofing_user\
    \x18\x17\x20\x01(\x08R\x11adminSpoofingUser\x12*\n\x0ftransport_error\
    \x18\x11\x20\x01(\x05:\x011R\x0etransportError\x122\n\tmessageid\x18\x12\
    \x20\x01(\x04:\x1418446744073709551615R\tmessageid\x12,\n\x12publisher_g\
    roup_id\x18\x13\x20\x01(\rR\x10publisherGroupId\x12\x14\n\x05sysid\x18\
    \x14\x20\x01(\rR\x05sysid\x12\x1b\n\ttrace_tag\x18\x15\x20\x01(\x04R\x08\
    traceTag\x12\"\n\rwebapi_key_id\x18\x19\x20\x01(\rR\x0bwebapiKeyId\x125\
    \n\x17is_from_external_source\x18\x1a\x20\x01(\x08R\x14isFromExternalSou\
    rce\x12(\n\x10forward_to_sysid\x18\x1b\x20\x03(\rR\x0eforwardToSysid\x12\
    \x19\n\x08cm_sysid\x18\x1c\x20\x01(\rR\x07cmSysid\x12\x19\n\x08wg_token\
    \x18\x1e\x20\x01(\tR\x07wgToken\x12&\n\rlauncher_type\x18\x1f\x20\x01(\r\
    :\x010R\x0clauncherType\x12\x17\n\x05realm\x18\x20\x20\x01(\r:\x010R\x05\
    realm\x12\x10\n\x02ip\x18\x0f\x20\x01(\rH\0R\x02ip\x12\x15\n\x05ip_v6\
    \x18\x1d\x20\x01(\x0cH\0R\x04ipV6B\t\n\x07ip_addr\"S\n\tCMsgMulti\x12#\n\
    \rsize_unzipped\x18\x01\x20\x01(\rR\x0csizeUnzipped\x12!\n\x0cmessage_bo\
    dy\x18\x02\x20\x01(\x0cR\x0bmessageBody\"8\n\x13CMsgProtobufWrapped\x12!\
    \n\x0cmessage_body\x18\x01\x20\x01(\x0cR\x0bmessageBody\"\xd0\x01\n\x0eC\
    MsgAuthTicket\x12\x16\n\x06estate\x18\x01\x20\x01(\rR\x06estate\x12\x1b\
    \n\x07eresult\x18\x02\x20\x01(\r:\x012R\x07eresult\x12\x18\n\x07steamid\
    \x18\x03\x20\x01(\x06R\x07steamid\x12\x16\n\x06gameid\x18\x04\x20\x01(\
    \x06R\x06gameid\x12\x20\n\x0ch_steam_pipe\x18\x05\x20\x01(\rR\nhSteamPip\
    e\x12\x1d\n\nticket_crc\x18\x06\x20\x01(\rR\tticketCrc\x12\x16\n\x06tick\
    et\x18\x07\x20\x01(\x0cR\x06ticket\"\xf0\x02\n\x14CCDDBAppDetailCommon\
    \x12\x14\n\x05appid\x18\x01\x20\x01(\rR\x05appid\x12\x12\n\x04name\x18\
    \x02\x20\x01(\tR\x04name\x12\x12\n\x04icon\x18\x03\x20\x01(\tR\x04icon\
    \x12\x12\n\x04logo\x18\x04\x20\x01(\tR\x04logo\x12\x1d\n\nlogo_small\x18\
    \x05\x20\x01(\tR\tlogoSmall\x12\x12\n\x04tool\x18\x06\x20\x01(\x08R\x04t\
    ool\x12\x12\n\x04demo\x18\x07\x20\x01(\x08R\x04demo\x12\x14\n\x05media\
    \x18\x08\x20\x01(\x08R\x05media\x126\n\x17community_visible_stats\x18\t\
    \x20\x01(\x08R\x15communityVisibleStats\x12#\n\rfriendly_name\x18\n\x20\
    \x01(\tR\x0cfriendlyName\x12\x20\n\x0bpropagation\x18\x0b\x20\x01(\tR\
    \x0bpropagation\x12*\n\x11has_adult_content\x18\x0c\x20\x01(\x08R\x0fhas\
    AdultContent\"\xfe\x04\n\rCMsgAppRights\x12\x1b\n\tedit_info\x18\x01\x20\
    \x01(\x08R\x08editInfo\x12\x18\n\x07publish\x18\x02\x20\x01(\x08R\x07pub\
    lish\x12&\n\x0fview_error_data\x18\x03\x20\x01(\x08R\rviewErrorData\x12\
    \x1a\n\x08download\x18\x04\x20\x01(\x08R\x08download\x12#\n\rupload_cdke\
    ys\x18\x05\x20\x01(\x08R\x0cuploadCdkeys\x12'\n\x0fgenerate_cdkeys\x18\
    \x06\x20\x01(\x08R\x0egenerateCdkeys\x12'\n\x0fview_financials\x18\x07\
    \x20\x01(\x08R\x0eviewFinancials\x12\x1d\n\nmanage_ceg\x18\x08\x20\x01(\
    \x08R\tmanageCeg\x12%\n\x0emanage_signing\x18\t\x20\x01(\x08R\rmanageSig\
    ning\x12#\n\rmanage_cdkeys\x18\n\x20\x01(\x08R\x0cmanageCdkeys\x12%\n\
    \x0eedit_marketing\x18\x0b\x20\x01(\x08R\reditMarketing\x12'\n\x0feconom\
    y_support\x18\x0c\x20\x01(\x08R\x0eeconomySupport\x12<\n\x1aeconomy_supp\
    ort_supervisor\x18\r\x20\x01(\x08R\x18economySupportSupervisor\x12%\n\
    \x0emanage_pricing\x18\x0e\x20\x01(\x08R\rmanagePricing\x12%\n\x0ebroadc\
    ast_live\x18\x0f\x20\x01(\x08R\rbroadcastLive\x124\n\x16view_marketing_t\
    raffic\x18\x10\x20\x01(\x08R\x14viewMarketingTraffic\"\xcd\x04\n\x13CCur\
    atorPreferences\x12/\n\x13supported_languages\x18\x01\x20\x01(\rR\x12sup\
    portedLanguages\x12)\n\x10platform_windows\x18\x02\x20\x01(\x08R\x0fplat\
    formWindows\x12!\n\x0cplatform_mac\x18\x03\x20\x01(\x08R\x0bplatformMac\
    \x12%\n\x0eplatform_linux\x18\x04\x20\x01(\x08R\rplatformLinux\x12\x1d\n\
    \nvr_content\x18\x05\x20\x01(\x08R\tvrContent\x124\n\x16adult_content_vi\
    olence\x18\x06\x20\x01(\x08R\x14adultContentViolence\x12*\n\x11adult_con\
    tent_sex\x18\x07\x20\x01(\x08R\x0fadultContentSex\x12+\n\x11timestamp_up\
    dated\x18\x08\x20\x01(\rR\x10timestampUpdated\x12%\n\x0etagids_curated\
    \x18\t\x20\x03(\rR\rtagidsCurated\x12'\n\x0ftagids_filtered\x18\n\x20\
    \x03(\rR\x0etagidsFiltered\x12#\n\rwebsite_title\x18\x0b\x20\x01(\tR\x0c\
    websiteTitle\x12\x1f\n\x0bwebsite_url\x18\x0c\x20\x01(\tR\nwebsiteUrl\
    \x12%\n\x0ediscussion_url\x18\r\x20\x01(\tR\rdiscussionUrl\x12%\n\x0esho\
    w_broadcast\x18\x0e\x20\x01(\x08R\rshowBroadcast\"[\n\x12CLocalizationTo\
    ken\x12\x1a\n\x08language\x18\x01\x20\x01(\rR\x08language\x12)\n\x10loca\
    lized_string\x18\x02\x20\x01(\tR\x0flocalizedString\"\xe6\x02\n\x17CClan\
    EventUserNewsTuple\x12\x16\n\x06clanid\x18\x01\x20\x01(\rR\x06clanid\x12\
    \x1b\n\tevent_gid\x18\x02\x20\x01(\x06R\x08eventGid\x12)\n\x10announceme\
    nt_gid\x18\x03\x20\x01(\x06R\x0fannouncementGid\x12\x1f\n\x0brtime_start\
    \x18\x04\x20\x01(\rR\nrtimeStart\x12\x1b\n\trtime_end\x18\x05\x20\x01(\r\
    R\x08rtimeEnd\x12%\n\x0epriority_score\x18\x06\x20\x01(\rR\rpriorityScor\
    e\x12\x12\n\x04type\x18\x07\x20\x01(\rR\x04type\x12(\n\x10clamp_range_sl\
    ot\x18\x08\x20\x01(\rR\x0eclampRangeSlot\x12\x14\n\x05appid\x18\t\x20\
    \x01(\rR\x05appid\x122\n\x15rtime32_last_modified\x18\n\x20\x01(\rR\x13r\
    time32LastModified\"\xac\x01\n\x16CClanMatchEventByRange\x12!\n\x0crtime\
    _before\x18\x01\x20\x01(\rR\x0brtimeBefore\x12\x1f\n\x0brtime_after\x18\
    \x02\x20\x01(\rR\nrtimeAfter\x12\x1c\n\tqualified\x18\x03\x20\x01(\rR\tq\
    ualified\x120\n\x06events\x18\x04\x20\x03(\x0b2\x18.CClanEventUserNewsTu\
    pleR\x06events\"\xca\x03\n\x1fCCommunity_ClanAnnouncementInfo\x12\x10\n\
    \x03gid\x18\x01\x20\x01(\x04R\x03gid\x12\x16\n\x06clanid\x18\x02\x20\x01\
    (\x04R\x06clanid\x12\x1a\n\x08posterid\x18\x03\x20\x01(\x04R\x08posterid\
    \x12\x1a\n\x08headline\x18\x04\x20\x01(\tR\x08headline\x12\x1a\n\x08post\
    time\x18\x05\x20\x01(\rR\x08posttime\x12\x1e\n\nupdatetime\x18\x06\x20\
    \x01(\rR\nupdatetime\x12\x12\n\x04body\x18\x07\x20\x01(\tR\x04body\x12\"\
    \n\x0ccommentcount\x18\x08\x20\x01(\x05R\x0ccommentcount\x12\x12\n\x04ta\
    gs\x18\t\x20\x03(\tR\x04tags\x12\x1a\n\x08language\x18\n\x20\x01(\x05R\
    \x08language\x12\x16\n\x06hidden\x18\x0b\x20\x01(\x08R\x06hidden\x12$\n\
    \x0eforum_topic_id\x18\x0c\x20\x01(\x06R\x0cforumTopicId\x12\x1b\n\teven\
    t_gid\x18\r\x20\x01(\x06R\x08eventGid\x12\x20\n\x0bvoteupcount\x18\x0e\
    \x20\x01(\x05R\x0bvoteupcount\x12$\n\rvotedowncount\x18\x0f\x20\x01(\x05\
    R\rvotedowncount\"\xa0\t\n\x0eCClanEventData\x12\x10\n\x03gid\x18\x01\
    \x20\x01(\x06R\x03gid\x12!\n\x0cclan_steamid\x18\x02\x20\x01(\x06R\x0bcl\
    anSteamid\x12\x1d\n\nevent_name\x18\x03\x20\x01(\tR\teventName\x12F\n\ne\
    vent_type\x18\x04\x20\x01(\x0e2\x14.EProtoClanEventType:\x11k_EClanOther\
    EventR\teventType\x12\x14\n\x05appid\x18\x05\x20\x01(\rR\x05appid\x12%\n\
    \x0eserver_address\x18\x06\x20\x01(\tR\rserverAddress\x12'\n\x0fserver_p\
    assword\x18\x07\x20\x01(\tR\x0eserverPassword\x12,\n\x12rtime32_start_ti\
    me\x18\x08\x20\x01(\rR\x10rtime32StartTime\x12(\n\x10rtime32_end_time\
    \x18\t\x20\x01(\rR\x0ertime32EndTime\x12#\n\rcomment_count\x18\n\x20\x01\
    (\x05R\x0ccommentCount\x12'\n\x0fcreator_steamid\x18\x0b\x20\x01(\x06R\
    \x0ecreatorSteamid\x12.\n\x13last_update_steamid\x18\x0c\x20\x01(\x06R\
    \x11lastUpdateSteamid\x12\x1f\n\x0bevent_notes\x18\r\x20\x01(\tR\neventN\
    otes\x12\x1a\n\x08jsondata\x18\x0e\x20\x01(\tR\x08jsondata\x12M\n\x11ann\
    ouncement_body\x18\x0f\x20\x01(\x0b2\x20.CCommunity_ClanAnnouncementInfo\
    R\x10announcementBody\x12\x1c\n\tpublished\x18\x10\x20\x01(\x08R\tpublis\
    hed\x12\x16\n\x06hidden\x18\x11\x20\x01(\x08R\x06hidden\x128\n\x18rtime3\
    2_visibility_start\x18\x12\x20\x01(\rR\x16rtime32VisibilityStart\x124\n\
    \x16rtime32_visibility_end\x18\x13\x20\x01(\rR\x14rtime32VisibilityEnd\
    \x123\n\x15broadcaster_accountid\x18\x14\x20\x01(\rR\x14broadcasterAccou\
    ntid\x12%\n\x0efollower_count\x18\x15\x20\x01(\rR\rfollowerCount\x12!\n\
    \x0cignore_count\x18\x16\x20\x01(\rR\x0bignoreCount\x12$\n\x0eforum_topi\
    c_id\x18\x17\x20\x01(\x06R\x0cforumTopicId\x122\n\x15rtime32_last_modifi\
    ed\x18\x18\x20\x01(\rR\x13rtime32LastModified\x12\"\n\rnews_post_gid\x18\
    \x19\x20\x01(\x06R\x0bnewsPostGid\x12,\n\x12rtime_mod_reviewed\x18\x1a\
    \x20\x01(\rR\x10rtimeModReviewed\x12,\n\x12featured_app_tagid\x18\x1b\
    \x20\x01(\rR\x10featuredAppTagid\x12+\n\x11referenced_appids\x18\x1c\x20\
    \x03(\rR\x10referencedAppids\"\xa7\x02\n\x10CBilling_Address\x12\x1d\n\n\
    first_name\x18\x01\x20\x01(\tR\tfirstName\x12\x1b\n\tlast_name\x18\x02\
    \x20\x01(\tR\x08lastName\x12\x1a\n\x08address1\x18\x03\x20\x01(\tR\x08ad\
    dress1\x12\x1a\n\x08address2\x18\x04\x20\x01(\tR\x08address2\x12\x12\n\
    \x04city\x18\x05\x20\x01(\tR\x04city\x12\x19\n\x08us_state\x18\x06\x20\
    \x01(\tR\x07usState\x12!\n\x0ccountry_code\x18\x07\x20\x01(\tR\x0bcountr\
    yCode\x12\x1a\n\x08postcode\x18\x08\x20\x01(\tR\x08postcode\x12\x1b\n\tz\
    ip_plus4\x18\t\x20\x01(\x05R\x08zipPlus4\x12\x14\n\x05phone\x18\n\x20\
    \x01(\tR\x05phone\"\xd3\x02\n\x19CPackageReservationStatus\x12\x1c\n\tpa\
    ckageid\x18\x01\x20\x01(\rR\tpackageid\x12+\n\x11reservation_state\x18\
    \x02\x20\x01(\x05R\x10reservationState\x12%\n\x0equeue_position\x18\x03\
    \x20\x01(\x05R\rqueuePosition\x12(\n\x10total_queue_size\x18\x04\x20\x01\
    (\x05R\x0etotalQueueSize\x128\n\x18reservation_country_code\x18\x05\x20\
    \x01(\tR\x16reservationCountryCode\x12\x18\n\x07expired\x18\x06\x20\x01(\
    \x08R\x07expired\x12!\n\x0ctime_expires\x18\x07\x20\x01(\rR\x0btimeExpir\
    es\x12#\n\rtime_reserved\x18\x08\x20\x01(\rR\x0ctimeReserved*\xeb\x07\n\
    \x13EProtoClanEventType\x12\x15\n\x11k_EClanOtherEvent\x10\x01\x12\x14\n\
    \x10k_EClanGameEvent\x10\x02\x12\x15\n\x11k_EClanPartyEvent\x10\x03\x12\
    \x17\n\x13k_EClanMeetingEvent\x10\x04\x12\x1c\n\x18k_EClanSpecialCauseEv\
    ent\x10\x05\x12\x1c\n\x18k_EClanMusicAndArtsEvent\x10\x06\x12\x16\n\x12k\
    _EClanSportsEvent\x10\x07\x12\x14\n\x10k_EClanTripEvent\x10\x08\x12\x14\
    \n\x10k_EClanChatEvent\x10\t\x12\x1b\n\x17k_EClanGameReleaseEvent\x10\n\
    \x12\x19\n\x15k_EClanBroadcastEvent\x10\x0b\x12\x1b\n\x17k_EClanSmallUpd\
    ateEvent\x10\x0c\x12&\n\"k_EClanPreAnnounceMajorUpdateEvent\x10\r\x12\
    \x1b\n\x17k_EClanMajorUpdateEvent\x10\x0e\x12\x1a\n\x16k_EClanDLCRelease\
    Event\x10\x0f\x12\x1d\n\x19k_EClanFutureReleaseEvent\x10\x10\x12&\n\"k_E\
    ClanESportTournamentStreamEvent\x10\x11\x12\x19\n\x15k_EClanDevStreamEve\
    nt\x10\x12\x12\x1c\n\x18k_EClanFamousStreamEvent\x10\x13\x12\x19\n\x15k_\
    EClanGameSalesEvent\x10\x14\x12\x1d\n\x19k_EClanGameItemSalesEvent\x10\
    \x15\x12\x1d\n\x19k_EClanInGameBonusXPEvent\x10\x16\x12\x1a\n\x16k_EClan\
    InGameLootEvent\x10\x17\x12\x1b\n\x17k_EClanInGamePerksEvent\x10\x18\x12\
    \x1f\n\x1bk_EClanInGameChallengeEvent\x10\x19\x12\x1d\n\x19k_EClanInGame\
    ContestEvent\x10\x1a\x12\x13\n\x0fk_EClanIRLEvent\x10\x1b\x12\x14\n\x10k\
    _EClanNewsEvent\x10\x1c\x12\x1b\n\x17k_EClanBetaReleaseEvent\x10\x1d\x12\
    $\n\x20k_EClanInGameContentReleaseEvent\x10\x1e\x12\x14\n\x10k_EClanFree\
    Trial\x10\x1f\x12\x18\n\x14k_EClanSeasonRelease\x10\x20\x12\x17\n\x13k_E\
    ClanSeasonUpdate\x10!\x12\x19\n\x15k_EClanCrosspostEvent\x10\"\x12\x1d\n\
    \x19k_EClanInGameEventGeneral\x10#*\x81\x01\n\x1cPartnerEventNotificatio\
    nType\x12\x11\n\rk_EEventStart\x10\0\x12\x1a\n\x16k_EEventBroadcastStart\
    \x10\x01\x12\x16\n\x12k_EEventMatchStart\x10\x02\x12\x1a\n\x16k_EEventPa\
    rtnerMaxType\x10\x03:S\n\x12msgpool_soft_limit\x18\xd0\x86\x03\x20\x01(\
    \x05\x12\x1f.google.protobuf.MessageOptions:\x0232R\x10msgpoolSoftLimit:\
    T\n\x12msgpool_hard_limit\x18\xd1\x86\x03\x20\x01(\x05\x12\x1f.google.pr\
    otobuf.MessageOptions:\x03384R\x10msgpoolHardLimit:W\n\x14force_php_gene\
    ration\x18\xd0\x86\x03\x20\x01(\x08\x12\x1c.google.protobuf.FileOptions:\
    \x05falseR\x12forcePhpGeneration:_\n\x18php_output_always_number\x18\xe4\
    \x86\x03\x20\x01(\x08\x12\x1d.google.protobuf.FieldOptions:\x05falseR\
    \x15phpOutputAlwaysNumberB\tH\x01\x80\x01\x01\x80\xb5\x18\x01\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> =
    ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| parse_descriptor_proto())
}
